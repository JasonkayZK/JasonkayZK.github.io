<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张小凯的博客</title>
  <icon>https://www.gravatar.com/avatar/0a440a9619579f1429aa17ed946ce69c</icon>
  
  <link href="https://jasonkayzk.github.io/atom.xml" rel="self"/>
  
  <link href="https://jasonkayzk.github.io/"/>
  <updated>2025-07-30T10:34:36.220Z</updated>
  <id>https://jasonkayzk.github.io/</id>
  
  <author>
    <name>Jasonkay</name>
    <email>jasonkayzk@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开了一个新的专门学习日语的博客</title>
    <link href="https://jasonkayzk.github.io/2025/07/30/%E5%BC%80%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%93%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AF%AD%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jasonkayzk.github.io/2025/07/30/%E5%BC%80%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%93%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AF%AD%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2025-07-30T05:22:44.000Z</published>
    <updated>2025-07-30T10:34:36.220Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直都在这里发一些学习日语相关的内容。但是感觉这些可以单独开一个新的网站来总结；</p><p>最近比较有时间，就开了一个新的坑；</p><p>博客主题用的是：<a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" target="_blank" rel="noopener">hexo-theme-anzhiyu</a>，真的很酷！</p><p>也是花了半个小时，使用hexo，从零搭建了一个博客；</p><p>之前没有好好总结，这里就又简单记录了一下搭建的过程，如果你还没有博客，可以跟着我一步一步来搭建一个GithubPages博客！</p><p>新博客地址：</p><ul><li><a href="https://jasonkayzk.github.io/jp/">https://jasonkayzk.github.io/jp/</a></li></ul><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/jp" target="_blank" rel="noopener">https://github.com/JasonkayZK/jp</a></li><li><a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" target="_blank" rel="noopener">https://github.com/anzhiyu-c/hexo-theme-anzhiyu</a></li></ul><br><a id="more"></a><h1 id="开了一个新的专门学习日语的博客"><a href="#开了一个新的专门学习日语的博客" class="headerlink" title="开了一个新的专门学习日语的博客"></a><strong>开了一个新的专门学习日语的博客</strong></h1><h2 id="一、安装Node-js-amp-Hexo"><a href="#一、安装Node-js-amp-Hexo" class="headerlink" title="一、安装Node.js&amp;Hexo"></a><strong>一、安装Node.js&amp;Hexo</strong></h2><p>可以在官网下载Node：</p><ul><li><a href="https://nodejs.org/zh-cn/download" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download</a></li></ul><blockquote><p>  <strong>我这里使用的是 fnm 作为版本管理工具；</strong></p><p>  <strong>配置国内源：</strong></p><pre><code class="bash">  # 国内 淘宝 镜像源  npm config set registry https://registry.npmmirror.com/</code></pre><p>  <strong>参考：</strong></p><ul><li><a href="https://ksh7.com/posts/npm-registry/index.html" target="_blank" rel="noopener">npm、yarn、pnpm 设置最新国内镜像源（附官方镜像源和最新阿里源），以及 nrm 的使用教程【2025】</a></li></ul></blockquote><p>也可以把 yarn 安装了：</p><pre><code class="bash">npm install -g yarn# 国内 淘宝 镜像源yarn config set registry https://registry.npmmirror.com/</code></pre><br><p>随后下载 Hexo-cli 命令行工具：</p><pre><code class="bash">npm install hexo-cli -g</code></pre><blockquote><p>  参考：</p><ul><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li></ul></blockquote><br><h2 id="二、初始化Hexo项目"><a href="#二、初始化Hexo项目" class="headerlink" title="二、初始化Hexo项目"></a><strong>二、初始化Hexo项目</strong></h2><p>直接通过命令行初始化项目 jp：</p><pre><code class="bash"># hexo init jpINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependencies......INFO  Start blogging with Hexo!</code></pre><p>安装依赖并测试：</p><pre><code class="bash">cd jpnpm ihexo s # 本地调试</code></pre><p>此时访问：</p><ul><li><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li></ul><p>你就能看到你的博客了！</p><blockquote><p>  <strong>参考文档：</strong></p><ul><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li></ul></blockquote><br><h2 id="三、更换主题"><a href="#三、更换主题" class="headerlink" title="三、更换主题"></a><strong>三、更换主题</strong></h2><p>默认的主题不太好看，可以在 github 上搜索 hexo 的相关主题（一般为 <code>hexo-</code> 开头）；</p><p>以 <a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" target="_blank" rel="noopener">hexo-theme-anzhiyu</a> 为例，文档：</p><ul><li><a href="https://docs.anheyu.com/" target="_blank" rel="noopener">https://docs.anheyu.com/</a></li></ul><p>首先在你项目的根目录将主题 clone 下来：</p><pre><code class="bash">git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu</code></pre><p>随后打开 <strong>Hexo</strong> 根目录下的 <code>config.yml</code>, 找到以下配置项，把主题改为<code>anzhiyu</code></p><pre><code class="yaml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: anzhiyu</code></pre><p>然后安装 pug 和 stylus 渲染插件：</p><pre><code class="bash">npm install hexo-renderer-pug hexo-renderer-stylus --save</code></pre><p>再次执行：</p><pre><code class="bash">hexo s</code></pre><p>此时再次访问：</p><ul><li><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li></ul><p>你就能看到你新的主题的博客了！</p><br><h2 id="四、自定义配置"><a href="#四、自定义配置" class="headerlink" title="四、自定义配置"></a><strong>四、自定义配置</strong></h2><p>拉下来的新的主题，很多内容大概率都不符合你的预期（比如：title、分类等等）；</p><p>此时你可以参考文档进行个性化的配置：</p><ul><li><a href="https://docs.anheyu.com/page/front-matter.html" target="_blank" rel="noopener">https://docs.anheyu.com/page/front-matter.html</a></li></ul><p>需要注意的是：</p><p><font color="#f00"><strong>在根目录下存在 <code>_config.yml</code>、各自主题下也有这个文件，优先级为：根目录 &gt; 各自主题配置！</strong></font></p><br><h2 id="五、撰写新的文章"><a href="#五、撰写新的文章" class="headerlink" title="五、撰写新的文章"></a><strong>五、撰写新的文章</strong></h2><p>通过：</p><pre><code class="bash">hexo new xxx</code></pre><p>即可创建一篇新的博文！</p><blockquote><p>  <font color="#f00"><strong>实际上就是在 <code>source/_posts/</code> 目录下创建了一个新的<code>*.md</code>文件而已！</strong></font></p></blockquote><p>可以增加 <code>Post Front-matter</code> 来对文章进行配置！</p><p>文章内容就按照 markdown 的格式去写就可以了！</p><br><h2 id="六、发布到Github"><a href="#六、发布到Github" class="headerlink" title="六、发布到Github"></a><strong>六、发布到Github</strong></h2><p>本地调试无误后，修改根目录下的 <code>_config.yml</code>：</p><pre><code class="yaml"># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: &#39;git&#39;  repo: git@github.com:jasonkayzk/jp.git  # 替换为你的仓库地址  branch: main  # 部署分支  </code></pre><p>安装插件：</p><pre><code class="bash">npm install hexo-deployer-git --save</code></pre><p>随后，在发布时，通常情况下：</p><ul><li>首先，通过 <code>hexo g</code> 生成静态资源；</li><li>然后使用 <code>hexo d</code> 即可部署！</li></ul><blockquote><p>  <strong>参考：</strong></p><ul><li><a href="https://hexo.io/docs/one-command-deployment" target="_blank" rel="noopener">https://hexo.io/docs/one-command-deployment</a></li></ul></blockquote><p><strong>但是这种方式每次都要在本地生成静态资源，效率太低！</strong></p><br><h3 id="1、使用GitHub-Actions自动部署"><a href="#1、使用GitHub-Actions自动部署" class="headerlink" title="1、使用GitHub Actions自动部署"></a><strong>1、使用GitHub Actions自动部署</strong></h3><p><font color="#f00"><strong>可以通过 Github Actions，每次 push 代码之后自动提交！</strong></font></p><p>在 <code>.github/workflows/</code> 目录下创建：</p><p>deploy.yml</p><pre><code class="yaml">name: Build &amp; Deploy Blogon:  workflow_dispatch:  push:    branches:      - devjobs:  build:    runs-on: ubuntu-latest    strategy:      matrix:        node_version: [18]    steps:      - name: Checkout source        uses: actions/checkout@v3        with:          ref: dev      - name: Cache dependencies        uses: actions/cache@v3        with:          path: |            node_modules            public          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}          restore-keys: |            ${{ runner.os }}-node-      - name: Use Node.js ${{ matrix.node_version }}        uses: actions/setup-node@v3        with:          version: ${{ matrix.node_version }}      - name: Add SSH key        uses: webfactory/ssh-agent@v0.7.0        with:          ssh-private-key: ${{ secrets.hexo_deploy_pri }}      - name: Setup hexo        run: |          git config --global user.email &quot;jasonkayzk@gmail.com&quot;          git config --global user.name &quot;jasonkayzk&quot;          npm install hexo-cli -g          npm install      - name: Hexo deploy        env:          GIT_SSH_COMMAND: ssh -o StrictHostKeyChecking=no        run: |          hexo clean          hexo g          hexo d</code></pre><p>随后在仓库的 <code>Secrets and variables</code> 设置中，添加 <code>Repository secrets</code>：</p><ul><li><strong>key为：<code>HEXO_DEPLOY_PRI</code>；</strong></li><li><strong>值为：你连接 Github 的私钥！（注意是私钥！）</strong></li></ul><p><strong>提交到 dev 分支后即可自动部署！</strong></p><br><h3 id="2、使用新分支保存笔记"><a href="#2、使用新分支保存笔记" class="headerlink" title="2、使用新分支保存笔记"></a><strong>2、使用新分支保存笔记</strong></h3><p>同时，生成的内容可能会覆盖原本的笔记<strong>（<code>hexo d</code> 会强行覆盖部署分支！）</strong>：</p><ul><li><strong>我们只需要 checkout 到另外的一个分支去编写博客，然后部署到 main 分支即可！</strong></li></ul><p>例如：</p><pre><code class="bash">git checkout -b devgit push</code></pre><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>新博客地址：</p><ul><li><a href="https://jasonkayzk.github.io/jp/">https://jasonkayzk.github.io/jp/</a></li></ul><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/jp" target="_blank" rel="noopener">https://github.com/JasonkayZK/jp</a></li><li><a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" target="_blank" rel="noopener">https://github.com/anzhiyu-c/hexo-theme-anzhiyu</a></li></ul><br>]]></content>
    
    
    <summary type="html">之前一直都在这里发一些学习日语相关的内容。但是感觉这些可以单独开一个新的网站来总结；最近比较有时间，就开了一个新的坑；博客主题用的是：hexo-theme-anzhiyu，真的很酷！也是花了半个小时，使用hexo，从零搭建了一个博客；之前没有好好总结，这里就又简单记录了一下搭建的过程，如果你还没有博客，可以跟着我一步一步来搭建一个GithubPages博客！</summary>
    
    
    
    <category term="日本語" scheme="https://jasonkayzk.github.io/categories/日本語/"/>
    
    
    <category term="日本語" scheme="https://jasonkayzk.github.io/tags/日本語/"/>
    
    <category term="博客管理" scheme="https://jasonkayzk.github.io/tags/博客管理/"/>
    
  </entry>
  
  <entry>
    <title>一、并行编程导论与CUDA入门</title>
    <link href="https://jasonkayzk.github.io/2025/07/29/%E4%B8%80%E3%80%81%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AE%BA%E4%B8%8ECUDA%E5%85%A5%E9%97%A8/"/>
    <id>https://jasonkayzk.github.io/2025/07/29/%E4%B8%80%E3%80%81%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AE%BA%E4%B8%8ECUDA%E5%85%A5%E9%97%A8/</id>
    <published>2025-07-29T09:41:50.000Z</published>
    <updated>2025-07-30T10:34:36.207Z</updated>
    
    <content type="html"><![CDATA[<p>随着人工智能的发展，科学计算（尤其是矩阵/张量计算）越来越重要；因此，基于CUDA的张量编程也越来越重要。</p><p>在<a href="https://github.com/JasonkayZK/high-performance-computing-learn/blob/main/cuda/0-an-even-easier-intro-to-cuda.ipynb" target="_blank" rel="noopener">上一篇笔记</a>中翻译了<a href="https://developer.nvidia.com/blog/even-easier-introduction-cuda/" target="_blank" rel="noopener">《An Even Easier Introduction to CUDA》</a>，但是感觉作者写的不是很好；</p><p>这里重新写了一篇。同时，也作为CUDA和并行编程的开篇。</p><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/high-performance-computing-learn/blob/main/cuda/1_introduction_to_parallel_programming_and_cuda.ipynb" target="_blank" rel="noopener">https://github.com/JasonkayZK/high-performance-computing-learn/blob/main/cuda/1_introduction_to_parallel_programming_and_cuda.ipynb</a></li></ul><br><a id="more"></a><h1 id="一、并行编程导论与CUDA入门"><a href="#一、并行编程导论与CUDA入门" class="headerlink" title="一、并行编程导论与CUDA入门"></a><strong>一、并行编程导论与CUDA入门</strong></h1><blockquote><p><strong>温馨提示：本文章配合 Colab 一同执行学习效果更佳：</strong></p><ul><li><a href="https://colab.research.google.com/github/JasonkayZK/high-performance-computing-learn/blob/main/cuda/1_introduction_to_parallel_programming_and_cuda.ipynb" target="_blank" rel="noopener">https://colab.research.google.com/github/JasonkayZK/high-performance-computing-learn/blob/main/cuda/1_introduction_to_parallel_programming_and_cuda.ipynb</a></li></ul></blockquote><h2 id="（一）、CUDA编程概述"><a href="#（一）、CUDA编程概述" class="headerlink" title="（一）、CUDA编程概述"></a><strong>（一）、CUDA编程概述</strong></h2><h3 id="1、什么是CUDA"><a href="#1、什么是CUDA" class="headerlink" title="1、什么是CUDA"></a><strong>1、什么是CUDA</strong></h3><p>CUDA 是 NVIDIA 开发的并行计算平台和编程模型；</p><p>具有以下特点：</p><ul><li>C/C++ 语法；</li><li>SIMT（Single Instruction Multiple Threads）模式：<strong>一个指令会被多个线程同时执行！</strong></li><li>需要与CPU协作：CPU负责整理结果、处理逻辑；</li><li>自动调度：根据设定的执行参数，自动调度；</li></ul><br><h3 id="2、CUDA-运算硬件单元"><a href="#2、CUDA-运算硬件单元" class="headerlink" title="2、CUDA 运算硬件单元"></a><strong>2、CUDA 运算硬件单元</strong></h3><h4 id="（1）SM-单元"><a href="#（1）SM-单元" class="headerlink" title="（1）SM 单元"></a><strong>（1）SM 单元</strong></h4><p>下面是一个 GPU 硬件单元：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-1.png" alt="cuda-1.png"></p><p>每个核心中包含了多个 SM（Stream Multi-processor），任务在 SM 中处理；</p><p>SM 中包含了：</p><ul><li><strong>CUDA Core/SP</strong>：进行并行的加减法等计算；</li><li><strong>Tensor Core：</strong>张量计算</li><li>……</li></ul><br><h4 id="（2）CPU与GPU协作"><a href="#（2）CPU与GPU协作" class="headerlink" title="（2）CPU与GPU协作"></a><strong>（2）CPU与GPU协作</strong></h4><p>CPU 与 GPU 协同工作的流程如下：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-2.png" alt="cuda-2.png"></p><p>首先，习惯上将：</p><ul><li>CPU 所在端称为：Host 端，对应内存为 RAM；</li><li>GPU 所在称为：Device 端，对应内存为 Global Memory（通常对应 GPU RAM，显存）；</li></ul><blockquote><p>  通常，Global Memory 在其范围和生命周期中是全局的！</p><p>  <strong>也就是说，每个在<a href="https://modal.com/gpu-glossary/device-software/thread-block-grid" target="_blank" rel="noopener">thread block grid</a> 中的 <a href="https://modal.com/gpu-glossary/device-software/thread" target="_blank" rel="noopener">thread</a> 都可以访问Global Memory，并且生命周期与程序的执行时间一样长！</strong></p><p>  <strong>更多内容：</strong></p><ul><li><a href="https://modal.com/gpu-glossary/device-software/global-memory" target="_blank" rel="noopener">https://modal.com/gpu-glossary/device-software/global-memory</a></li></ul></blockquote><p>CUDA 程序执行时主要分为以下几个步骤：</p><ul><li><strong>CPU 准备（CPU Prepare）</strong>：在主机端（Host ，包含 CPU 和 RAM 主存 ），CPU 负责初始化数据、设置计算参数等准备工作，为后续在 GPU 上的运算任务做铺垫，确定要处理的数据和运算逻辑；</li><li><strong>CPU 传输数据至 GPU（CPU Transfers Data to GPU）</strong>：通过总线（Bus），CPU 把主存（RAM）中准备好的数据传输到 GPU 端的全局内存（Global Memory ，GM），因为 GPU 运算需要的数据要先存放到其可访问的内存空间；</li><li><strong>从 GM 读数据（Read Data from GM）</strong>：GPU（如 NVIDIA A100 ）从自身的全局内存中读取需要参与运算的数据，将数据加载到运算单元可处理的位置；</li><li><strong>运算（Compute）</strong>：NVIDIA A100 等 GPU 设备利用自身的并行运算核心，对读取的数据执行 CUDA 核函数定义的运算操作，发挥 GPU 并行计算优势，高效处理大规模数据计算任务；</li><li><strong>写回 GM（Write Back to GM）</strong>：运算完成后，GPU 将运算结果写回到全局内存中，暂存运算产出的数据；</li><li><strong>GPU 传输数据至 CPU（GPU Transfers Data to CPU）</strong>：再次通过总线，GPU 把全局内存中存储的运算结果传输回主机端的主存（RAM），供 CPU 进一步处理（如数据展示、后续其他主机端逻辑运算等 ），完成一次 CUDA 编程的计算流程；</li></ul><p>CUDA 这种流程实现了 CPU 与 GPU 协同，让 GPU 承担并行计算 heavy - lifting ，提升计算密集型任务效率，广泛用于深度学习训练推理、科学计算等场景！</p><br><h2 id="（二）、CUDA运算示例：加法"><a href="#（二）、CUDA运算示例：加法" class="headerlink" title="（二）、CUDA运算示例：加法"></a><strong>（二）、CUDA运算示例：加法</strong></h2><h3 id="1、CPU加法"><a href="#1、CPU加法" class="headerlink" title="1、CPU加法"></a><strong>1、CPU加法</strong></h3><p>add_cpu.cpp</p><pre><code class="c++">#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;// Step 2: Define add functionvoid add_cpu(std::vector&lt;float&gt; &amp;c, const std::vector&lt;float&gt; &amp;a, const std::vector&lt;float&gt; &amp;b) {    // CPU use loop to calculate    for (size_t i = 0; i &lt; a.size(); i++) {        c[i] = a[i] + b[i];    }}int main() {    // Step 1: Prepare &amp; initialize data    constexpr size_t N = 1 &lt;&lt; 20; // ~1M elements    // Initialize data    const std::vector&lt;float&gt; a(N, 1);    const std::vector&lt;float&gt; b(N, 2);    std::vector&lt;float&gt; c(N, 0);    // Step 3: Call the cpu addition function    add_cpu(c, a, b);    // Step 4: Check for errors (all values should be 3.0f)    float maxError = 0.0f;    for (int i = 0; i &lt; N; i++) {        maxError = fmax(maxError, fabs(c[i] - 3.0f));    }    std::cout &lt;&lt; &quot;Max error: &quot; &lt;&lt; maxError &lt;&lt; std::endl;}</code></pre><p>主要分为以下几个步骤：</p><ul><li>准备和初始化数据；</li><li>定义加法函数<ul><li>靠<strong>循环</strong>来进行所有的元素加法</li></ul></li><li>调用函数</li><li>验证结果</li></ul><br><h3 id="2、修改为GPU加法（重点！）"><a href="#2、修改为GPU加法（重点！）" class="headerlink" title="2、修改为GPU加法（重点！）"></a><strong>2、修改为GPU加法（重点！）</strong></h3><p>分为以下几个步骤：</p><ul><li><strong>修改文件名为 <code>*.cu</code></strong>：例如<code>add_cuda.cu</code>（表示 CUDA 程序）</li><li><strong>准备和初始化数据（CPU）</strong>：使用 vector 等进行 Host 端的 RAM 分配；</li><li><strong>数据传输到 GPU</strong>：使用 <code>cudaMalloc</code> 分配显存、使用 <code>cudaMemcpy</code> 复制数据等；</li><li><strong>GPU 从 GM 中读取并计算后写回（调用核（kernel）函数计算）</strong>：<ul><li>修改核函数声明：</li><li>修改调用方式：</li></ul></li><li><strong>将 GPU 数据传输回 CPU</strong>：</li><li>验证结果</li></ul><p>下面分别来看；</p><br><h4 id="（1）修改文件名为-cu"><a href="#（1）修改文件名为-cu" class="headerlink" title="（1）修改文件名为 *.cu"></a>（1）修改文件名为 <code>*.cu</code></h4><p>CUDA 规定其文件扩展名为 <code>*.cu</code>，语法和 C++ 类似！</p><br><h4 id="（2）准备和初始化数据（CPU）"><a href="#（2）准备和初始化数据（CPU）" class="headerlink" title="（2）准备和初始化数据（CPU）"></a><strong>（2）准备和初始化数据（CPU）</strong></h4><p>这步比较简单：</p><p>add_cuda.cu</p><pre><code class="c++">// Step 1: Prepare &amp; initialize dataconstexpr size_t N = 1 &lt;&lt; 20; // ~1M elementsconstexpr size_t size_bytes = sizeof(float) * N;// Initialize dataconst std::vector&lt;float&gt; h_a(N, 1);const std::vector&lt;float&gt; h_b(N, 2);std::vector&lt;float&gt; h_c(N, 0);</code></pre><p>此时在 Host 端的 RAM 分配内存；</p><br><h4 id="（3）数据传输到-GPU"><a href="#（3）数据传输到-GPU" class="headerlink" title="（3）数据传输到 GPU"></a><strong>（3）数据传输到 GPU</strong></h4><p>数据传输到 GPU 使用 CUDA 提供的函数：</p><ul><li>使用 <code>cudaMalloc</code> 分配显存；</li><li>使用 <code>cudaMemcpy</code> 复制数据；</li></ul><p>add_cuda.cu</p><pre><code class="c++">float *d_a, *d_b, *d_c;CUDA_CHECK(cudaMalloc(&amp;d_a, size_bytes));CUDA_CHECK(cudaMalloc(&amp;d_b, size_bytes));CUDA_CHECK(cudaMalloc(&amp;d_c, size_bytes));CUDA_CHECK(cudaMemcpy(d_a, h_a.data(), size_bytes, cudaMemcpyHostToDevice));CUDA_CHECK(cudaMemcpy(d_b, h_b.data(), size_bytes, cudaMemcpyHostToDevice));CUDA_CHECK(cudaMemcpy(d_c, h_c.data(), size_bytes, cudaMemcpyHostToDevice));</code></pre><p>这里使用了：</p><ul><li><code>CUDA_CHECK</code> 宏进行校验；</li><li><code>cudaMemcpyHostToDevice</code> 指定数据流方向；</li></ul><p>CUDA_CHECK 宏定义如下：</p><pre><code class="c++">#define CUDA_CHECK(call) \{ \    cudaError_t err = call; \    if (err != cudaSuccess) { \        std::cerr &lt;&lt; &quot;CUDA Error at &quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ \        &lt;&lt; &quot; - &quot; &lt;&lt; cudaGetErrorString(err) &lt;&lt; std::endl; \    } \}</code></pre><br><h4 id="（4：补）CUDA层级结构"><a href="#（4：补）CUDA层级结构" class="headerlink" title="（4：补）CUDA层级结构"></a><strong>（4：补）CUDA层级结构</strong></h4><h5 id="i-线程层级结构"><a href="#i-线程层级结构" class="headerlink" title="i.线程层级结构"></a><strong>i.线程层级结构</strong></h5><p>在 CPU 中，使用<strong>循环</strong>进行执行；</p><p><strong>而在 GPU 中，使用的是 <code>SIMT</code>，即：<code>一条命令会同时被多个线程执行！</code></strong></p><p><strong>此时需要指挥每个线程：组织结构和编号！</strong></p><p>在 CUDA 中，包含：</p><ul><li>Grid：</li><li>Block：</li><li>Thread：</li></ul><p>如下图：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-3.png" alt="cuda-3.png"></p><p>其中：<strong>每一个 Grid 中包含多个已编号的 Block，而每一个 Block 中包含多个已编号的 Thread！</strong></p><p>同时，<strong>每个 Block 中包含的线程数是一样的！</strong></p><p><strong>一共有：<code>0~N-1</code>个Thread（假设每个 Block 包含 N 个 Thread）；</strong></p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-4.png" alt="cuda-4.png"></p><br><h5 id="ii-线程索引计算方法"><a href="#ii-线程索引计算方法" class="headerlink" title="ii.线程索引计算方法"></a><strong>ii.线程索引计算方法</strong></h5><p>在 CUDA 中：</p><ul><li>每个线程都有 <strong>独一无二</strong> 的编号索引(idx)；</li><li><code>idx = BlockID * BlockSize + ThreadID</code>；</li></ul><p>如下图：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-5.png" alt="cuda-5.png"></p><br><h4 id="（4）编写和调用核函数"><a href="#（4）编写和调用核函数" class="headerlink" title="（4）编写和调用核函数"></a><strong>（4）编写和调用核函数</strong></h4><p>相对于 CPU 中使用循环的方式执行，<strong>在 GPU 中主要使用的是：<code>多线程并行</code>；</strong></p><p>步骤如下：</p><ul><li>定义 block 的数量和大小来指挥线程、进行/并行计算；</li><li>定义 GPU 上的加法函数（核函数）；</li><li>结合定义的信息调用 GPU 加法函数；</li></ul><p>层级结构定义：</p><pre><code class="c++">// Set up kernel configurationdim3 block_dim(256);dim3 grid_dim((N + block_dim.x - 1) / block_dim.x);</code></pre><p>核函数定义：</p><pre><code class="c++">template&lt;typename T&gt;__global__ void add_kernel(T *c, const T *a, const T *b, int n) {    int idx = blockIdx.x * blockDim.x + threadIdx.x;    if (idx &lt; n) {        c[idx] = a[idx] + b[idx];    }}</code></pre><blockquote><p>  <strong>只能通过指针的方式传递！</strong></p><p>  <font color="#f00"><strong>因为像是 vector 等数据结构，都是在 Host 端定义的，并不能在 Global Memory 中分配！</strong></font></p></blockquote><p>核函数调用：</p><pre><code class="c++">// Call cuda add kerneladd_kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(d_c, d_a, d_b, N);</code></pre><p>其中：</p><ul><li><code>dim3</code>：CUDA 表示线程层级结构的类型（包括：x、y、z 三个维度）；</li><li><code>&lt;&lt;&lt;&gt;&gt;&gt;</code>：传递线程层级信息给核函数；</li><li><code>核函数(kernel)</code>：设备侧的入口函数；</li><li><code>__global__</code>：表示这是个核函数；</li><li><code>blockldx</code>：表示 block 的编号，第几个 block；</li><li><code>blockDim</code>：表示 block 的大小，一个 block 多少个线程；</li><li><code>threadldx</code>：表示 thread 的编号，表示第几个 thread；</li></ul><br><h4 id="（5）将-GPU-数据传输回-CPU"><a href="#（5）将-GPU-数据传输回-CPU" class="headerlink" title="（5）将 GPU 数据传输回 CPU"></a><strong>（5）将 GPU 数据传输回 CPU</strong></h4><p>同样，使用 <code>cudaMemcpy</code>：</p><pre><code class="c++">CUDA_CHECK(cudaMemcpy(h_c.data(), d_c, size_bytes, cudaMemcpyDeviceToHost));</code></pre><br><h4 id="（6）验证结果，释放内存"><a href="#（6）验证结果，释放内存" class="headerlink" title="（6）验证结果，释放内存"></a><strong>（6）验证结果，释放内存</strong></h4><p>验证结果使用已经复制到 <code>h_c</code> 中的数据；</p><p>释放内存使用 <code>cudaFree</code>：</p><p>add_cuda.cu</p><pre><code class="c++">float maxError = 0.0f;for (int i = 0; i &lt; N; i++) {    maxError = fmax(maxError, fabs(h_c[i] - 3.0f));}std::cout &lt;&lt; &quot;Max error: &quot; &lt;&lt; maxError &lt;&lt; std::endl;if (d_a) {    CUDA_CHECK(cudaFree(d_a));}if (d_b) {    CUDA_CHECK(cudaFree(d_b));}if (d_c) {    CUDA_CHECK(cudaFree(d_c));}</code></pre><br><h3 id="3、编译-amp-运行CUDA程序"><a href="#3、编译-amp-运行CUDA程序" class="headerlink" title="3、编译&amp;运行CUDA程序"></a><strong>3、编译&amp;运行CUDA程序</strong></h3><p>需要使用 <code>NVCC（NIVIDEA CUDA Compiler）</code> 的编译器来编译程序；</p><blockquote><p>  NVCC 是 CUDA Toolkit 的一部分：</p><ul><li><a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit</a></li></ul></blockquote><br><h4 id="（1）编译流程"><a href="#（1）编译流程" class="headerlink" title="（1）编译流程"></a><strong>（1）编译流程</strong></h4><p>如下图所示：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-6.png" alt="cuda-6.png"></p><p>流程如下：</p><ol><li><strong>每个 cu</strong>：Host 代码与 Device 代码分离（部分在CPU执行、部分在GPU执行）</li><li><strong>每个虚拟架构：</strong>Device 代码编译出 fatbin</li><li>Host 端使用系统的 C++ 编译器(如 g++)</li><li>链接（device，host）</li><li>最终获得可使用 GPU 的可执行二进制文件</li></ol><br><h5 id="补：GPU虚拟架构"><a href="#补：GPU虚拟架构" class="headerlink" title="补：GPU虚拟架构"></a><strong>补：GPU虚拟架构</strong></h5><p>NVIDIA 不同年代生产的GPU可能有不同的架构，如下图所示：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-7.png" alt="cuda-7.png"></p><p>以 A100 为例，A100 为 Ampere 架构；同时，各个架构间有区别；</p><p>因此提出：Compute Capability (CC)</p><ul><li>类似版本，表示能支持的功能和指令集合</li><li>A100 (Ampere 架构)是：cc8.0</li></ul><blockquote><p>  <strong>虽然 A100 举例，但从 CUDA 编程的角度目前各种架构没有本质区别！</strong></p><p>  <font color="#f00"><strong>正因为如此，所以说CUDA是一个编程平台</strong></font></p></blockquote><p>同时，在编译时也可以指定架构编译选项：</p><ul><li><code>-arch</code>：指定虚拟架构，PTX生成目标。决定代码中可使用的CUDA 功能；</li><li><code>-code</code>：指定实际架构，生成针对特定 GPU 硬件的二进制机器码(cubin)；</li></ul><br><h4 id="（2）编译命令"><a href="#（2）编译命令" class="headerlink" title="（2）编译命令"></a><strong>（2）编译命令</strong></h4><p>通过：</p><pre><code class="bash">nvcc add_cuda.cu -o add_cuda</code></pre><p>即可编译！</p><p>运行：</p><pre><code class="bash">./add_cuda</code></pre><br><h2 id="（三）、GPU性能测试"><a href="#（三）、GPU性能测试" class="headerlink" title="（三）、GPU性能测试"></a>（三）、GPU性能测试</h2><p>可以通过：</p><pre><code>nvidia-smi</code></pre><p>观察 GPU 利用率！</p><h3 id="1、并行加法性能对比"><a href="#1、并行加法性能对比" class="headerlink" title="1、并行加法性能对比"></a><strong>1、并行加法性能对比</strong></h3><p>分别对比：</p><ul><li>CPU；</li><li><code>&lt;&lt;&lt;1,1&gt;&gt;&gt;</code>；</li><li><code>&lt;&lt;&lt;256，256&gt;&gt;&gt;</code>；</li><li>GPU 满载；</li></ul><p>代码如下：</p><p>add_cuda_profiling.cu</p><pre><code class="c++">#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define CUDA_CHECK(call) \{ \    cudaError_t err = call; \    if (err != cudaSuccess) { \        std::cerr &lt;&lt; &quot;CUDA Error at &quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ \        &lt;&lt; &quot; - &quot; &lt;&lt; cudaGetErrorString(err) &lt;&lt; std::endl; \    } \}// Step 3: Define add kerneltemplate&lt;typename T&gt;__global__ void add_kernel(T *c, const T *a, const T *b, const size_t n, const size_t step) {    int idx = blockIdx.x * blockDim.x + threadIdx.x + step;    if (idx &lt; n) {        c[idx] = a[idx] + b[idx];    }}template&lt;typename T&gt;void vector_add(T *c, const T *a, const T *b, size_t n, const dim3&amp; grid_dim, const dim3&amp; block_dim) {    size_t step = grid_dim.x * block_dim.x;    for (size_t i = 0; i &lt; n; i += step) {        add_kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(c, a, b, n, i);    }}int main() {    // Step 1: Prepare &amp; initialize data    constexpr size_t N = 1 &lt;&lt; 20; // ~1M elements    constexpr size_t size_bytes = sizeof(float) * N;    // Initialize data    const std::vector&lt;float&gt; h_a(N, 1);    const std::vector&lt;float&gt; h_b(N, 2);    std::vector&lt;float&gt; h_c(N, 0);    // Step 2: Allocate device memory &amp; transfer to global memory    float *d_a, *d_b, *d_c;    CUDA_CHECK(cudaMalloc(&amp;d_a, size_bytes));    CUDA_CHECK(cudaMalloc(&amp;d_b, size_bytes));    CUDA_CHECK(cudaMalloc(&amp;d_c, size_bytes));    CUDA_CHECK(cudaMemcpy(d_a, h_a.data(), size_bytes, cudaMemcpyHostToDevice));    CUDA_CHECK(cudaMemcpy(d_b, h_b.data(), size_bytes, cudaMemcpyHostToDevice));    CUDA_CHECK(cudaMemcpy(d_c, h_c.data(), size_bytes, cudaMemcpyHostToDevice));    // Step 4: Call the cpu addition function    // Set up kernel configuration    dim3 block_dim(1);    dim3 grid_dim(1);    // Call cuda add kernel    vector_add(d_c, d_a, d_b, N, block_dim, grid_dim);    // Step 5: Transfer data from global mem to host mem    CUDA_CHECK(cudaMemcpy(h_c.data(), d_c, size_bytes, cudaMemcpyDeviceToHost));    // Step 6: Check for errors (all values should be 3.0f)    float sumError = 0.0f;    for (int i = 0; i &lt; N; i++) {        sumError += fabs(h_c[i] - 3.0f);    }    std::cout &lt;&lt; &quot;Sum error: &quot; &lt;&lt; sumError &lt;&lt; std::endl;    if (d_a) {        CUDA_CHECK(cudaFree(d_a));    }    if (d_b) {        CUDA_CHECK(cudaFree(d_b));    }    if (d_c) {        CUDA_CHECK(cudaFree(d_c));    }}</code></pre><blockquote><p>  可以修改其中的：</p><pre><code class="c++">  dim3 block_dim(1);  dim3 grid_dim(1);</code></pre></blockquote><p>不同情况下的性能如下：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-8.png" alt="cuda-8.png"></p><p>可以使用 Nsight Systems（nsys，NVIDIA系统级性能分析工具）来分析；</p><p>启动 profiling：</p><pre><code class="bash">nsys profile -t cuda,nvtx,osrt -o add_cuda_profiling -f true ./add_cuda_profiling</code></pre><p>解析并统计性能信息：</p><pre><code class="bash">nsys stats add_cuda_profiling.nsys-rep ** OS Runtime Summary (osrt_sum): Time (%)  Total Time (ns)  Num Calls    Avg (ns)       Med (ns)      Min (ns)    Max (ns)     StdDev (ns)            Name          --------  ---------------  ---------  -------------  -------------  ----------  -----------  -------------  ----------------------     56.2    7,592,724,284         84   90,389,574.8  100,130,776.0       2,330  370,626,986   45,049,255.4  poll                       42.4    5,736,493,727         26  220,634,374.1  189,702,756.5  41,077,614  752,975,386  124,762,585.8  sem_wait                    1.2      164,252,099        543      302,490.1       13,509.0         529  111,402,991    4,818,716.4  ioctl                       0.1       14,968,499         38      393,907.9      131,267.0         135    5,539,804      890,642.6  pthread_rwlock_wrlock                 ...... ** CUDA API Summary (cuda_api_sum): Time (%)  Total Time (ns)  Num Calls    Avg (ns)     Med (ns)    Min (ns)   Max (ns)     StdDev (ns)            Name          --------  ---------------  ---------  ------------  -----------  --------  -----------  -------------  ----------------------     96.9    6,504,565,162  1,048,576       6,203.2      5,159.0     2,928   37,814,020       99,097.6  cudaLaunchKernel            3.0      203,141,797          3  67,713,932.3    103,908.0    73,162  202,964,727  117,130,625.1  cudaMalloc                  0.1        4,017,591          4   1,004,397.8  1,012,632.0   941,545    1,050,782       45,652.8  cudaMemcpy                  0.0          524,788          3     174,929.3    136,182.0   122,785      265,821       78,999.0  cudaFree                    0.0            2,584          1       2,584.0      2,584.0     2,584        2,584            0.0  cuModuleGetLoadingMode......</code></pre><p>各个类型 API Summary 分析结果如下：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-9.png" alt="cuda-9.png"></p><p>可以看到：<code>&lt;&lt;&lt;1,1&gt;&gt;&gt;</code> cudaLaunchKernel 占比非常高这是由于：</p><p><strong>核函数调用有开销，在外面多次循环调用开销巨大！</strong></p><p>因此，需要进行优化！</p><br><h3 id="2、将循环放入核函数（Grid-strided-loop）"><a href="#2、将循环放入核函数（Grid-strided-loop）" class="headerlink" title="2、将循环放入核函数（Grid-strided loop）"></a><strong>2、将循环放入核函数（Grid-strided loop）</strong></h3><p>由于在循环中频繁的调用核函数具有巨大的性能开销，因此可以将循环放入核函数中：</p><pre><code class="c++">template&lt;typename T&gt;__global__ void add_kernel_inner_loop(T *c, const T *a, const T *b, const size_t n, const size_t step) {    int idx = blockIdx.x * blockDim.x + threadIdx.x;    for (size_t i = idx; i &lt; n; i += step) {        if (i &lt; n) {            c[i] = a[i] + b[i];        }    }}template&lt;typename T&gt;void vector_add(T *c, const T *a, const T *b, size_t n, const dim3&amp; grid_dim, const dim3&amp; block_dim) {    size_t step = grid_dim.x * block_dim.x;    add_kernel_inner_loop&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(c, a, b, n, step);}</code></pre><p>分析后结果如下图：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/cuda-10.png" alt="cuda-10.png"></p><p>同时使用 nsys 分析：</p><pre><code class="bash"> ** CUDA API Summary (cuda_api_sum): Time (%)  Total Time (ns)  Num Calls    Avg (ns)     Med (ns)    Min (ns)   Max (ns)     StdDev (ns)            Name          --------  ---------------  ---------  ------------  -----------  --------  -----------  -------------  ----------------------     55.4      204,935,456          3  68,311,818.7    104,741.0    79,097  204,751,618  118,160,333.0  cudaMalloc                 44.4      164,057,041          4  41,014,260.3  1,000,521.5   926,775  161,129,223   80,076,651.2  cudaMemcpy                  0.2          653,441          3     217,813.7    204,732.0   194,409      254,300       32,016.9  cudaFree                    0.1          264,055          1     264,055.0    264,055.0   264,055      264,055            0.0  cudaLaunchKernel            0.0            2,429          1       2,429.0      2,429.0     2,429        2,429            0.0  cuModuleGetLoadingMode</code></pre><p>可以看到 cudaLaunchKernel 的确少了很多！ </p><blockquote><p>  这说明：</p><p>  <font color="#f00"><strong>核函数的发射数量减少，因此总体执行时间降低！</strong></font></p></blockquote><br><h3 id="3、CUDA并行加法性能评估（加速比）"><a href="#3、CUDA并行加法性能评估（加速比）" class="headerlink" title="3、CUDA并行加法性能评估（加速比）"></a><strong>3、CUDA并行加法性能评估（加速比）</strong></h3><p>指标：</p><p>加速比 = T<sub>cpu</sub> / T<sub>gpu</sub></p><p>其中：</p><ul><li><strong>T_cpu</strong> 是任务在 CPU 上的执行时间；</li><li><strong>T_gpu</strong> 是任务在 GPU 上的执行时间；</li></ul><blockquote><p>  <strong>理想加速比与实际加速比</strong></p><ol><li><strong>理想加速比</strong>：当任务完全并行化且没有任何开销时，加速比等于处理器核心数之比。例如，一个具有 1000 个 CUDA 核心的 GPU 理论上可以实现 1000 倍的加速（相对于单核 CPU）。</li><li><strong>实际加速比</strong>：由于以下因素，实际加速比通常远低于理想值：<ul><li>任务中存在无法并行化的串行部分</li><li>数据在 CPU 和 GPU 之间的传输开销</li><li>线程同步和内存访问延迟</li><li>算法在 GPU 架构上的效率低下</li></ul></li></ol></blockquote><h4 id="为什么-lt-lt-lt-1-1-gt-gt-gt-比-CPU慢？"><a href="#为什么-lt-lt-lt-1-1-gt-gt-gt-比-CPU慢？" class="headerlink" title="为什么&lt;&lt;&lt;1,1&gt;&gt;&gt; 比 CPU慢？"></a><strong>为什么<code>&lt;&lt;&lt;1,1&gt;&gt;&gt;</code> 比 CPU慢？</strong></h4><p>这是由于，单个 GPU 的核心实际上要比 CPU 的能力要弱！</p><p>实际上，GPU 是由于干活的人多，所以快！</p><br><h3 id="4、CUDA并行加法性能评估（总耗时）"><a href="#4、CUDA并行加法性能评估（总耗时）" class="headerlink" title="4、CUDA并行加法性能评估（总耗时）"></a><strong>4、CUDA并行加法性能评估（总耗时）</strong></h3><p>实际上观察 nsys 的输出结果：</p><pre><code class="bash"> ** CUDA GPU Kernel Summary (cuda_gpu_kern_sum): Time (%)  Total Time (ns)  Instances    Avg (ns)       Med (ns)      Min (ns)     Max (ns)    StdDev (ns)                                              Name                                              --------  ---------------  ---------  -------------  -------------  -----------  -----------  -----------  ---------------------------------------------------------------------------------------------    100.0      160,054,287          1  160,054,287.0  160,054,287.0  160,054,287  160,054,287          0.0  void add_kernel_inner_loop&lt;float&gt;(T1 *, const T1 *, const T1 *, unsigned long, unsigned long)Processing [add_cuda_profiling2.sqlite] with [/usr/local/cuda-12.1/nsight-systems-2023.1.2/host-linux-x64/reports/cuda_gpu_mem_time_sum.py]...  ** CUDA GPU MemOps Summary (by Time) (cuda_gpu_mem_time_sum): Time (%)  Total Time (ns)  Count  Avg (ns)   Med (ns)   Min (ns)  Max (ns)  StdDev (ns)      Operation      --------  ---------------  -----  ---------  ---------  --------  --------  -----------  ------------------     78.4        2,318,310      3  772,770.0  763,159.0   761,400   793,751     18,191.4  [CUDA memcpy HtoD]     21.6          640,473      1  640,473.0  640,473.0   640,473   640,473          0.0  [CUDA memcpy DtoH]</code></pre><p>总体的耗时应当是三个部分：</p><ul><li><strong>总耗时 = T<sub>H2D</sub> + T<sub>kernel</sub> + T<sub>D2H</sub></strong></li></ul><p>并且，对于 <code>&lt;&lt;&lt;256,256&gt;&gt;&gt;</code> 来说：<strong>HtoD 和 DtoH 的耗时会远大于 kernel 的运行时间！</strong></p><blockquote><p>  <strong>这就说明，来回的移动和复制数据比计算更消耗时间！</strong></p></blockquote><p>能否对这一部分进行优化呢？</p><p>后面的文章中会讲解！</p><br><h2 id="（四）、设备信息"><a href="#（四）、设备信息" class="headerlink" title="（四）、设备信息"></a><strong>（四）、设备信息</strong></h2><p>对于 GPU 而言：<strong>越多的线程 =&gt; 越大的并行度 =&gt; 越好的性能</strong></p><p>GPU 最大可以启动的线程数可以参考：</p><ul><li>官网查询硬件：<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications</a></li><li>代码动态获取（cudaDeivceProp）：<a href="https://docs.nvidia.com/cuda/cuda-runtime-api/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-runtime-api/index.html</a></li></ul><blockquote><p>  也可以参考：</p><ul><li><a href="https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf" target="_blank" rel="noopener">https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf</a></li></ul></blockquote><br><h3 id="1、cudaDeivceProp"><a href="#1、cudaDeivceProp" class="headerlink" title="1、cudaDeivceProp"></a><strong>1、cudaDeivceProp</strong></h3><p>重点的几个参数：</p><ul><li><strong>maxGridSize（int[3]）</strong>：x、y、z三个方向分别最多可支持的 block 数；</li><li><strong>maxBlockSize（int[3]）</strong>：每个 Block中x、y、z三个方向分别最多可支持的线程数；</li><li><strong>maxThreadsPerBlock（int）</strong>：每个 block 中最多可有的线程数</li></ul><blockquote><p>  <strong>其中：Blocksize 需同时满足这两组条件：maxBlockSize、maxThreadsPerBlock：</strong></p><ul><li>x、y、z加起来不超过：maxThreadsPerBlock；</li><li>x、y、z各个方向不超过：maxBlockSize；</li></ul></blockquote><br><h3 id="2、CUDA版本"><a href="#2、CUDA版本" class="headerlink" title="2、CUDA版本"></a><strong>2、CUDA版本</strong></h3><p>查看 CUDA 版本使用：</p><pre><code class="bash"># CUDA版本nvcc --versionnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2023 NVIDIA CorporationBuilt on Tue_Feb__7_19:32:13_PST_2023Cuda compilation tools, release 12.1, V12.1.66Build cuda_12.1.r12.1/compiler.32415258_0</code></pre><blockquote><p>  可以看到 CUDA 为 12.1！</p></blockquote><p>而 <code>nvidia-smi</code> 命令输出的是：<strong>驱动支持的的最高版本，而非实际正在使用的版本！</strong></p><pre><code class="bash">Tue Jul 29 09:30:09 2025       +-----------------------------------------------------------------------------------------+| NVIDIA-SMI 550.54.15              Driver Version: 550.54.15      CUDA Version: 12.4     ||-----------------------------------------+------------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. ||                                         |                        |               MIG M. ||=========================================+========================+======================||   0  Tesla T4                       Off |   00000000:00:04.0 Off |                    0 || N/A   38C    P8             10W /   70W |       0MiB /  15360MiB |      0%      Default ||                                         |                        |                  N/A |+-----------------------------------------+------------------------+----------------------++-----------------------------------------------------------------------------------------+| Processes:                                                                              ||  GPU   GI   CI        PID   Type   Process name                              GPU Memory ||        ID   ID                                                               Usage      ||=========================================================================================||  No running processes found                                                             |+-----------------------------------------------------------------------------------------+</code></pre><blockquote><p>  <strong>可以看到，最高支持 12.4！</strong></p></blockquote><br><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h2><p>更加详细的内容，可以看：</p><ul><li><a href="https://qiankunli.github.io/2025/03/22/cuda.html" target="_blank" rel="noopener">https://qiankunli.github.io/2025/03/22/cuda.html</a></li></ul><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/high-performance-computing-learn/blob/main/cuda/1_introduction_to_parallel_programming_and_cuda.ipynb" target="_blank" rel="noopener">https://github.com/JasonkayZK/high-performance-computing-learn/blob/main/cuda/1_introduction_to_parallel_programming_and_cuda.ipynb</a></li></ul><p>参考文章：</p><ul><li><a href="https://beta.infinitensor.com/camp/summer2025/stage/1/course/cuda-programming" target="_blank" rel="noopener">https://beta.infinitensor.com/camp/summer2025/stage/1/course/cuda-programming</a></li><li><a href="https://qiankunli.github.io/2025/03/22/cuda.html#simd%E5%92%8Csimt" target="_blank" rel="noopener">https://qiankunli.github.io/2025/03/22/cuda.html#simd%E5%92%8Csimt</a></li><li><a href="https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf" target="_blank" rel="noopener">https://www.nvidia.cn/docs/IO/51635/NVIDIA_CUDA_Programming_Guide_1.1_chs.pdf</a></li></ul><br>]]></content>
    
    
    <summary type="html">随着人工智能的发展，科学计算（尤其是矩阵/张量计算）越来越重要；因此，基于CUDA的张量编程也越来越重要。在上一篇文章中翻译了《An Even Easier Introduction to CUDA》，但是感觉作者写的不是很好；这里重新写了一篇。同时，也作为CUDA和并行编程的开篇。</summary>
    
    
    
    <category term="CUDA" scheme="https://jasonkayzk.github.io/categories/CUDA/"/>
    
    
    <category term="CUDA" scheme="https://jasonkayzk.github.io/tags/CUDA/"/>
    
    <category term="GPU" scheme="https://jasonkayzk.github.io/tags/GPU/"/>
    
    <category term="并行计算" scheme="https://jasonkayzk.github.io/tags/并行计算/"/>
    
  </entry>
  
  <entry>
    <title>一些免费的GPU资源</title>
    <link href="https://jasonkayzk.github.io/2025/07/24/%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E7%9A%84GPU%E8%B5%84%E6%BA%90/"/>
    <id>https://jasonkayzk.github.io/2025/07/24/%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E7%9A%84GPU%E8%B5%84%E6%BA%90/</id>
    <published>2025-07-24T07:37:04.000Z</published>
    <updated>2025-07-30T10:34:36.208Z</updated>
    
    <content type="html"><![CDATA[<p>在学习AI时，经常需要用到GPU资源；而有些时候我们手头并没有老黄的显卡，或者显卡已经不支持进行人工智能的学习了；</p><p>本文总结了一些常用的GPU资源；</p><p>同时，后续也会在博客更新一些和并行计算、人工智能相关的内容，敬请期待！</p><br><a id="more"></a><h1 id="一些免费的GPU资源"><a href="#一些免费的GPU资源" class="headerlink" title="一些免费的GPU资源"></a><strong>一些免费的GPU资源</strong></h1><h2 id="一、Google-Colab（推荐）"><a href="#一、Google-Colab（推荐）" class="headerlink" title="一、Google Colab（推荐）"></a><strong>一、Google Colab（推荐）</strong></h2><p>网址：</p><ul><li><a href="https://colab.research.google.com/notebooks/" target="_blank" rel="noopener">https://colab.research.google.com/notebooks/</a></li></ul><p>特点：</p><ul><li>提供 <strong>NVIDIA T4/P100/V100/A100</strong>（具体型号随机分配）；</li><li>免费用户每天最多可使用 12 小时（可能因资源调度而中断）；</li><li>可升级至 <strong>Colab Pro（9.99 美元/月）</strong>或 <strong>Colab Pro+（49.99 美元/月）</strong>，享受更长运行时间和优惠优先级；</li><li>集成 Jupyter Notebook 环境，适合深度学习和机器学习任务</li></ul><br><h2 id="二、Kaggle"><a href="#二、Kaggle" class="headerlink" title="二、Kaggle"></a><strong>二、Kaggle</strong></h2><p>网址：</p><ul><li><a href="https://www.kaggle.com/" target="_blank" rel="noopener">https://www.kaggle.com/</a></li></ul><p>特点：</p><ul><li><strong>GPU小时数</strong>：每周30小时。</li><li><strong>GPU</strong>：提供Tesla P100，与Google Colab的T4相当。</li><li><strong>使用质量</strong>：非常好，很少断连。</li><li><strong>CPU和内存</strong>：提供四个CPU和29GB RAM。</li><li><strong>易用性</strong>：易用，有类似笔记本的界面。</li><li><strong>存储</strong>：无持久性存储。</li></ul><br><h2 id="三、Paperspace-Gradient"><a href="#三、Paperspace-Gradient" class="headerlink" title="三、Paperspace Gradient"></a><strong>三、Paperspace Gradient</strong></h2><p>网址：</p><ul><li><a href="https://www.paperspace.com/" target="_blank" rel="noopener">https://www.paperspace.com/</a></li></ul><p>特点：</p><ul><li><strong>GPU小时数</strong>：无具体限制，质量不佳。</li><li><strong>存储</strong>：有持久性存储，数据不会丢失。</li><li><strong>GPU</strong>：提供M4000 GPU，质量低于Google Colab的T4。</li></ul><br><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a><strong>四、其他</strong></h2><h3 id="1、AWS-Sagemaker-Studio-Lab"><a href="#1、AWS-Sagemaker-Studio-Lab" class="headerlink" title="1、AWS Sagemaker Studio Lab"></a><strong>1、AWS Sagemaker Studio Lab</strong></h3><p>特点：</p><ul><li><strong>GPU小时数</strong>：每天4小时，CPU小时数12小时。</li><li><strong>GPU</strong>：提供T4 GPU，与Google Colab相同。</li><li><strong>使用质量</strong>：非常好，很少断连。</li><li><strong>易用性</strong>：需要在网站上注册。</li><li><strong>存储</strong>：有持久性存储。</li></ul><br><h3 id="2、Lightning-AI"><a href="#2、Lightning-AI" class="headerlink" title="2、Lightning AI"></a><strong>2、Lightning AI</strong></h3><p>网址：</p><ul><li><a href="https://lightning.ai/" target="_blank" rel="noopener">https://lightning.ai/</a></li></ul><p>特点：</p><ul><li><strong>GPU小时数</strong>：每月22小时。</li><li><strong>CPU</strong>：提供一个Studio，4个CPU完全免费。</li><li><strong>使用质量</strong>：非常好，连接稳定。</li><li><strong>易用性</strong>：非常好，提供VS Code界面。</li></ul><br><h3 id="3、百度-AI-Studio"><a href="#3、百度-AI-Studio" class="headerlink" title="3、百度 AI Studio"></a><strong>3、百度 AI Studio</strong></h3><p>网址：</p><ul><li><a href="https://aistudio.baidu.com/index" target="_blank" rel="noopener">https://aistudio.baidu.com/index</a></li></ul><p>特点：</p><ul><li>免费提供 GPU 运行环境，支持常见型号（如 T4、P40 等，具体配置可能随时调整）；</li><li>集成 PaddlePaddle 以及 TensorFlow、PyTorch 等主流深度学习框架；</li><li>类似 Jupyter Notebook 的在线编程环境，适合快速上手、学习和实验；</li></ul><br><h3 id="4、云平台注册赠费"><a href="#4、云平台注册赠费" class="headerlink" title="4、云平台注册赠费"></a><strong>4、云平台注册赠费</strong></h3><ul><li><strong>Google Cloud Free Tier</strong><ul><li>新用户可获得 300 美元免费试用额度（90 天内有效），体验包括 GPU 实例在内的众多云服务</li><li>用户可自行创建 NVIDIA T4/V100/A100 GPU 实例（需手动配置）</li><li>适用于大规模机器学习和 AI 训练</li><li>注册时需绑定信用卡，但试用期间不会产生扣费</li></ul></li><li><strong>Microsoft Azure Free Tier</strong><ul><li>新用户可获得 200 美元免费试用额度（30 天内有效），支持 GPU 虚拟机（如 NC/ND 系列）</li><li>适用于 AI 深度学习训练和企业级应用开发</li><li>需要信用卡验证，但试用期间不收费</li></ul></li><li><strong>AWS Free Tier（Amazon Web Services）</strong><ul><li>免费层主要提供 750 小时 t2.micro 实例（不含 GPU），部分新用户可额外申请 GPU 实例（如 p3/g4 系列）</li><li>提供 Amazon SageMaker 平台，支持机器学习项目的快速部署</li><li>注册需绑定信用卡，确保试用过程不产生费用</li></ul></li></ul><blockquote><p>  其他资源：</p><ul><li><a href="https://www.reddit.com/r/KoboldAI/comments/13taldr/google_colabs_possible_alternatives/" target="_blank" rel="noopener">https://www.reddit.com/r/KoboldAI/comments/13taldr/google_colabs_possible_alternatives/</a></li><li><a href="https://deepnote.com/compare/alternatives/colab" target="_blank" rel="noopener">https://deepnote.com/compare/alternatives/colab</a></li></ul></blockquote><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/1906295351289308808" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/1906295351289308808</a></li><li><a href="https://www.bilibili.com/read/cv34465418/" target="_blank" rel="noopener">https://www.bilibili.com/read/cv34465418/</a></li><li><a href="https://www.reddit.com/r/KoboldAI/comments/13taldr/google_colabs_possible_alternatives/" target="_blank" rel="noopener">https://www.reddit.com/r/KoboldAI/comments/13taldr/google_colabs_possible_alternatives/</a></li><li><a href="https://deepnote.com/compare/alternatives/colab" target="_blank" rel="noopener">https://deepnote.com/compare/alternatives/colab</a></li></ul><br>]]></content>
    
    
    <summary type="html">在学习AI时，经常需要用到GPU资源；而有些时候我们手头并没有老黄的显卡，或者显卡已经不支持进行人工智能的学习了；本文总结了一些常用的GPU资源；同时，后续也会在博客更新一些和并行计算、人工智能相关的内容，敬请期待！</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="人工智能" scheme="https://jasonkayzk.github.io/tags/人工智能/"/>
    
  </entry>
  
  <entry>
    <title>debian12部署kubernetes-1.28集群</title>
    <link href="https://jasonkayzk.github.io/2025/07/21/debian12%E9%83%A8%E7%BD%B2kubernetes-1-28%E9%9B%86%E7%BE%A4/"/>
    <id>https://jasonkayzk.github.io/2025/07/21/debian12%E9%83%A8%E7%BD%B2kubernetes-1-28%E9%9B%86%E7%BE%A4/</id>
    <published>2025-07-21T02:41:07.000Z</published>
    <updated>2025-07-30T10:34:36.203Z</updated>
    
    <content type="html"><![CDATA[<p>由于暑假到了以及天气原因，学校的k8s集群暂时关闭了，但是目前还是有使用k8s的需求，花了2个小时又重新搭了一下；</p><p>由于国内网络的问题，导致github包、镜像都很难拉下来，因此本文的内容更适合国内需求环境。</p><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/kubernetes-learn" target="_blank" rel="noopener">https://github.com/JasonkayZK/kubernetes-learn</a></li></ul><br><a id="more"></a><h1 id="debian12部署kubernetes-1-28集群"><a href="#debian12部署kubernetes-1-28集群" class="headerlink" title="debian12部署kubernetes-1.28集群"></a><strong>debian12部署kubernetes-1.28集群</strong></h1><h2 id="零、前置工作"><a href="#零、前置工作" class="headerlink" title="零、前置工作"></a><strong>零、前置工作</strong></h2><h3 id="0、环境校验"><a href="#0、环境校验" class="headerlink" title="0、环境校验"></a><strong>0、环境校验</strong></h3><p>该部分内容来自于 <a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener"><code>K8S</code> 官方文档</a>：</p><ul><li>一台兼容的 <code>Linux</code> 主机。<code>Kubernetes</code> 项目为基于 <code>Debian</code> 和 <code>Red Hat</code> 的 <code>Linux</code> 发行版以及一些不提供包管理器的发行版提供通用的指令。</li><li>每台机器 <code>2 GB</code> 或更多的 <code>RAM</code>（如果少于这个数字将会影响你应用的运行内存）。</li><li><code>CPU 2</code> 核心及以上。</li><li>集群中的所有机器的网络彼此均能相互连接（公网和内网都可以）。</li><li>节点之中不可以有重复的主机名、<code>MAC</code> 地址或 <code>product_uuid</code>。</li></ul><br><h3 id="1、准备虚拟机"><a href="#1、准备虚拟机" class="headerlink" title="1、准备虚拟机"></a><strong>1、准备虚拟机</strong></h3><table><thead><tr><th>IP Address</th><th>Hostname</th><th>CPU</th><th>Memory</th><th>Storage</th><th>OS Release</th><th>Role</th></tr></thead><tbody><tr><td>192.168.117.200</td><td>k1</td><td>4C</td><td>8G</td><td>100GB</td><td>Debian 12</td><td>Master</td></tr><tr><td>192.168.117.201</td><td>k2</td><td>4C</td><td>8G</td><td>100GB</td><td>Debian 12</td><td>Worker</td></tr><tr><td>192.168.117.202</td><td>k3</td><td>4C</td><td>8G</td><td>100GB</td><td>Debian 12</td><td>Worker</td></tr></tbody></table><p>虚拟机安装、配置部分不再赘述了！</p><p>主要包括下面几个方面：</p><ul><li>配置软件源；</li><li>配置静态IP；</li><li>配置 hosts 解析；</li><li>配置 SSH 免密登录；</li><li>安装必要工具：net-tools、wget、curl、htop等；</li></ul><blockquote><p>  参考：</p><ul><li><a href="/2021/08/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%95%9C%E5%83%8F-1/">《从零开始搭建大数据镜像-1》</a></li></ul></blockquote><br><h3 id="2、卸载docker（如有）"><a href="#2、卸载docker（如有）" class="headerlink" title="2、卸载docker（如有）"></a><strong>2、卸载docker（如有）</strong></h3><p>新版本的 k8s 和 docker 底层都依赖 containerd 容易造成冲突，直接卸载docker：</p><pre><code class="bash">sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrassudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerdsudo rm -rf /etc/docker</code></pre><br><h3 id="3、设置系统时区和时间同步"><a href="#3、设置系统时区和时间同步" class="headerlink" title="3、设置系统时区和时间同步"></a><strong>3、设置系统时区和时间同步</strong></h3><p>使用阿里云的时钟源：</p><pre><code class="bash">timedatectl set-timezone Asia/Shanghai# 安装 chronyapt-get install -y chrony# 修改为阿里的时钟源sed -i &quot;s/pool 2.debian.pool.ntp.org iburst/server ntp.aliyun.com iburst/g&quot; /etc/chrony/chrony.conf# 启用并立即启动 chrony 服务systemctl restart chronysystemctl enable chrony# 查看与 chrony 服务器同步的时间源chronyc sources</code></pre><br><h3 id="4、安装ipvs工具"><a href="#4、安装ipvs工具" class="headerlink" title="4、安装ipvs工具"></a><strong>4、安装ipvs工具</strong></h3><p>在 <code>Kubernetes</code> 中，<code>ipset</code> 和 <code>ipvsadm</code> 的用途：</p><ul><li><code>ipset</code> 主要用于支持 <code>Service</code> 的负载均衡和网络策略。它可以帮助实现高性能的数据包过滤和转发，以及对 <code>IP</code> 地址和端口进行快速匹配。</li><li><code>ipvsadm</code> 主要用于配置和管理 <code>IPVS</code> 负载均衡器，以实现 <code>Service</code> 的负载均衡。</li></ul><p>执行：</p><pre><code class="bash">apt-get install -y ipset ipvsadm </code></pre><br><h3 id="5、关闭服务"><a href="#5、关闭服务" class="headerlink" title="5、关闭服务"></a><strong>5、关闭服务</strong></h3><p>关闭 swap、防火墙等：</p><pre><code class="bash"># 关闭所有已激活的 swap 分区swapoff -a# 禁用系统启动时自动挂载 swap 分区sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab# 停止 AppArmor 服务systemctl stop apparmor.service# 禁用 AppArmor 服务systemctl disable apparmor.service# 禁用 Uncomplicated Firewall（ufw）ufw disable# 停止 ufw 服务systemctl stop ufw.service# 禁用 ufw 服务systemctl disable ufw.service</code></pre><br><h3 id="6、内核优化"><a href="#6、内核优化" class="headerlink" title="6、内核优化"></a><strong>6、内核优化</strong></h3><p>创建一个名为 kubernetes.conf 的内核配置文件，并写入以下配置内容：</p><pre><code class="bash">cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF# 允许 IPv6 转发请求通过iptables进行处理（如果禁用防火墙或不是iptables，则该配置无效）net.bridge.bridge-nf-call-ip6tables = 1# 允许 IPv4 转发请求通过iptables进行处理（如果禁用防火墙或不是iptables，则该配置无效）net.bridge.bridge-nf-call-iptables = 1# 启用IPv4数据包的转发功能net.ipv4.ip_forward = 1# 禁用发送 ICMP 重定向消息net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.send_redirects = 0# 提高 TCP 连接跟踪的最大数量net.netfilter.nf_conntrack_max = 1000000# 提高连接追踪表的超时时间net.netfilter.nf_conntrack_tcp_timeout_established = 86400# 提高监听队列大小net.core.somaxconn = 1024# 防止 SYN 攻击net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 2048net.ipv4.tcp_synack_retries = 2# 提高文件描述符限制fs.file-max = 65536# 设置虚拟内存交换（swap）的使用策略为0，减少对磁盘的频繁读写vm.swappiness = 0EOF</code></pre><p>加载或启动内核模块 br_netfilter，该模块提供了网络桥接所需的网络过滤功能</p><pre><code>modprobe br_netfilter</code></pre><p>查看是否已成功加载模块：</p><pre><code class="bash">lsmod | grep br_netfilter</code></pre><p>将读取该文件中的参数设置，并将其应用到系统的当前运行状态中：</p><pre><code class="bash">sysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><blockquote><p>  参考：</p><ul><li><a href="https://isekiro.com/linux操作系统-内核优化/" target="_blank" rel="noopener">Linux操作系统-内核优化</a></li></ul></blockquote><br><h3 id="7、内核模块配置"><a href="#7、内核模块配置" class="headerlink" title="7、内核模块配置"></a><strong>7、内核模块配置</strong></h3><p>将自定义在系统引导时自动加载的内核模块：</p><pre><code class="bash"># 将自定义在系统引导时自动加载的内核模块cat &gt; /etc/modules-load.d/kubernetes.conf &lt;&lt; EOF# /etc/modules-load.d/kubernetes.conf# Linux 网桥支持br_netfilter# IPVS 加载均衡器ip_vsip_vs_rrip_vs_wrrip_vs_sh# IPv4 连接跟踪nf_conntrack_ipv4# IP 表规则ip_tablesEOF</code></pre><p>添加可执行权限：</p><pre><code class="bash">chmod a+x /etc/modules-load.d/kubernetes.conf</code></pre><br><h3 id="8、安装containerd运行时"><a href="#8、安装containerd运行时" class="headerlink" title="8、安装containerd运行时"></a><strong>8、安装containerd运行时</strong></h3><blockquote><p>  <strong>以下指令适用于 Kubernetes 1.28！</strong></p></blockquote><h4 id="（1）安装"><a href="#（1）安装" class="headerlink" title="（1）安装"></a><strong>（1）安装</strong></h4><p>安装 containerd：</p><pre><code class="bash"># cri-containerd 比 containerd 多了 runcwget https://github.com/containerd/containerd/releases/download/v1.7.21/cri-containerd-1.7.21-linux-amd64.tar.gztar xf cri-containerd-1.7.21-linux-amd64.tar.gz -C /# 创建目录，该目录用于存放 containerd 配置文件mkdir /etc/containerd# 创建一个默认的 containerd 配置文件containerd config default &gt; /etc/containerd/config.toml# 修改配置文件中使用的沙箱镜像版本sed -i &#39;s#registry.k8s.io/pause:3.8#registry.aliyuncs.com/google_containers/pause:3.9#&#39; /etc/containerd/config.toml# 设置容器运行时（containerd + CRI）在创建容器时使用 Systemd Cgroups 驱动sed -i &#39;/SystemdCgroup/s/false/true/&#39; /etc/containerd/config.toml# 修改存储目录# mkdir /data1/containerd# sed -i &#39;s#root = &quot;/var/lib/containerd&quot;#root = &quot;/data1/containerd&quot;#&#39; /etc/containerd/config.toml</code></pre><br><h4 id="（2）配置脚本"><a href="#（2）配置脚本" class="headerlink" title="（2）配置脚本"></a><strong>（2）配置脚本</strong></h4><p>配置启动脚本：</p><p>/lib/systemd/system/containerd.service</p><pre><code class="ini">[Unit]Description=containerd container runtimeDocumentation=https://containerd.ioAfter=network.target local-fs.target[Service]ExecStartPre=-/sbin/modprobe overlayExecStart=/usr/local/bin/containerdType=notifyDelegate=yesKillMode=processRestart=alwaysRestartSec=5LimitNPROC=infinityLimitCORE=infinityTasksMax=infinityOOMScoreAdjust=-999[Install]WantedBy=multi-user.target</code></pre><p>执行配置：</p><pre><code class="bash"># 启用并立即启动 containerd 服务systemctl enable --now containerd.service# 检查 containerd 服务的当前状态systemctl status containerd.service# 检查 containerd crictl runc 的版本containerd --versioncrictl --versionrunc --versioncrictl config runtime-endpoint unix:///run/containerd/containerd.sock</code></pre><br><h2 id="一、安装组件"><a href="#一、安装组件" class="headerlink" title="一、安装组件"></a><strong>一、安装组件</strong></h2><p>更新 apt 包索引并安装使用 Kubernetes apt 仓库所需要的包：</p><pre><code class="bash">sudo apt-get update# apt-transport-https 可能是一个虚拟包（dummy package）；如果是的话，你可以跳过安装这个包sudo apt-get install -y apt-transport-https ca-certificates curl gpg#下载用于 Kubernetes 软件包仓库的公共签名密钥。所有仓库都使用相同的签名密钥，因此你可以忽略URL中的版本：curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg#添加 Kubernetes apt 仓库。 请注意，此仓库仅包含适用于 Kubernetes 1.28 的软件包； 对于其他 Kubernetes 次要版本，则需要更改 URL 中的 Kubernetes 次要版本以匹配你所需的次要版本 （你还应该检查正在阅读的安装文档是否为你计划安装的 Kubernetes 版本的文档）。# 此操作会覆盖 /etc/apt/sources.list.d/kubernetes.list 中现存的所有配置。echo &#39;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /&#39; | sudo tee /etc/apt/sources.list.d/kubernetes.list#更新 apt 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本：sudo apt-get updatesudo apt-get install -y kubelet=1.28.13-1.1 kubeadm=1.28.13-1.1 kubectl=1.28.13-1.1#锁定版本sudo apt-mark hold kubelet kubeadm kubectl#说明：在 Debian 12 和 Ubuntu 22.04 之前的早期版本中，默认情况下不存在 /etc/apt/keyrings 目录； 你可以通过运行 sudo mkdir -m 755 /etc/apt/keyrings 来创建它。</code></pre><p>配置 kubelet 开机启动：</p><pre><code class="bash">systemctl enable kubelet</code></pre><br><h2 id="二、初始化集群"><a href="#二、初始化集群" class="headerlink" title="二、初始化集群"></a><strong>二、初始化集群</strong></h2><h3 id="1、初始化集群（Master节点执行）"><a href="#1、初始化集群（Master节点执行）" class="headerlink" title="1、初始化集群（Master节点执行）"></a><strong>1、初始化集群（Master节点执行）</strong></h3><blockquote><p>  <strong>本小节在 master 节点执行！</strong></p></blockquote><p>生成配置文件：</p><pre><code class="bash">kubeadm config print init-defaults &gt; kubeadm.yaml</code></pre><p>配置文件如下：</p><p>kubeadm.yaml</p><pre><code class="yaml">apiVersion: kubeadm.k8s.io/v1beta3bootstrapTokens:- groups:  - system:bootstrappers:kubeadm:default-node-token  token: abcdef.0123456789abcdef  ttl: 24h0m0s  usages:  - signing  - authenticationkind: InitConfiguration#localAPIEndpoint:#  advertiseAddress: 192.168.2.232#  bindPort: 6443nodeRegistration:  criSocket: unix:///run/containerd/containerd.sock  imagePullPolicy: IfNotPresent#  name: node  taints: null---apiServer:  timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta3certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: {}dns: {}etcd:  local:    dataDir: /var/lib/etcd# 指定阿里云镜像以及k8s版本imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containerskind: ClusterConfigurationkubernetesVersion: 1.28.13# 新增controlPlaneEndpoint: 192.168.117.200:6443 # 修改为masterIP！networking:  dnsDomain: cluster.local  serviceSubnet: 10.254.0.0/16  podSubnet: 10.255.0.0/16  # 指定pod网段scheduler: {}# 新增如下：---apiVersion: kubelet.config.k8s.io/v1beta1kind: KubeletConfigurationcgroupDriver: systemd---apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationmode: ipvs</code></pre><p>验证镜像仓配置是否生效。</p><pre><code class="bash">kubeadm config images list --config=kubeadm.yaml</code></pre><p>提前拉取镜像。</p><pre><code class="bash">kubeadm config images pull --config=kubeadm.yaml</code></pre><p>查看镜像是否下载。</p><pre><code class="bash">crictl images</code></pre><p>开始初始化。</p><pre><code class="bash">kubeadm init --config=kubeadm.yaml</code></pre><p>安装完会有加入集群的相关指令：</p><pre><code class="bash">You should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of control-plane nodes by copying certificate authoritiesand service account keys on each node and then running the following as root:  kubeadm join 192.168.117.200:6443 --token abcdef.0123456789abcdef \        --discovery-token-ca-cert-hash sha256:91a2398cbadf3967950dc6900e7411d5319e82ad30e139a1163896f9a8c61234 \        --control-plane Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.117.200:6443 --token abcdef.0123456789abcdef \        --discovery-token-ca-cert-hash sha256:91a2398cbadf3967950dc6900e7411d5319e82ad30e139a1163896f9a8c61234</code></pre><br><h3 id="2、Worker加入集群（Worker节点）"><a href="#2、Worker加入集群（Worker节点）" class="headerlink" title="2、Worker加入集群（Worker节点）"></a><strong>2、Worker加入集群（Worker节点）</strong></h3><blockquote><p>  <strong>此小节在 worker 节点执行！</strong></p></blockquote><p>执行加入脚本：</p><pre><code class="bash">kubeadm join 192.168.117.200:6443 --token abcdef.0123456789abcdef \        --discovery-token-ca-cert-hash sha256:91a2398cbadf3967950dc6900e7411d5319e82ad30e139a1163896f9a8c61234</code></pre><p>等待后即可加入！</p><br><h3 id="3、Master节点污点（可选）"><a href="#3、Master节点污点（可选）" class="headerlink" title="3、Master节点污点（可选）"></a><strong>3、Master节点污点（可选）</strong></h3><p>默认情况下 Master 节点为 <code>control-plane</code>，无法部署服务；</p><p>可以通过执行：</p><pre><code class="bash"># 查看污点kubectl describe node k1 |grep TaintsTaints:    node-role.kubernetes.io/control-plane:NoSchedule# 删除污点kubectl taint node k1 node-role.kubernetes.io/control-plane:NoSchedule-</code></pre><p>启用 master 节点调度！</p><br><h3 id="补：其他节点使用kubectl"><a href="#补：其他节点使用kubectl" class="headerlink" title="补：其他节点使用kubectl"></a><strong>补：其他节点使用kubectl</strong></h3><p>其他节点默认是无法直接使用 kubectl 管理集群的，我们只需要将配置文件复制到其他节点即可！</p><p><strong>方法一：拷贝master节点的/etc/kubernetes/admin.conf 到nodes节点中的同样的目录/etc/kubernetes/ ，然后再配置环境变量</strong></p><pre><code class="bash">[root@k8s-node1 qq-5201351]# scp k8s-master:/etc/kubernetes/admin.conf /etc/kubernetes/admin.conf</code></pre><p>然后再配置环境变量：</p><pre><code class="bash">echo &#39;export KUBECONFIG=/etc/kubernetes/admin.conf&#39; &gt;&gt; ~/.bash_profilesource ~/.bash_profile</code></pre> <br><p><strong>方法二：拷贝master节点的/etc/kubernetes/admin.conf 到nodes节点的$HOME/.kube目录，并且命名为config</strong></p><p>因为默认是没有 <code>$HOME/.kube</code> 目录的，先进行创建：</p><ul><li><strong>mkdir -p $HOME/.kube</strong></li><li><strong>scp k8s-master:/etc/kubernetes/admin.conf $HOME/.kube/config</strong></li></ul><br><h2 id="三、网络插件"><a href="#三、网络插件" class="headerlink" title="三、网络插件"></a><strong>三、网络插件</strong></h2><h3 id="1、安装Calico"><a href="#1、安装Calico" class="headerlink" title="1、安装Calico"></a><strong>1、安装Calico</strong></h3><p>k8s 部署完成后还不能使用，需要配置网络插件，从而为 Pod 分配 IP，打通网络等等。</p><blockquote><p>  Calico是 <strong>目前开源的最成熟的纯三层网络框架之一</strong>， 是一种广泛采用、久经考验的开源网络和网络安全解决方案，适用于 Kubernetes、虚拟机和裸机工作负载。 Calico 为云原生应用提供两大服务：工作负载之间的网络连接和工作负载之间的网络安全策略。</p><p>  Calico 访问链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fprojectcalico.docs.tigera.io%2Fabout%2Fabout-calico" target="_blank" rel="noopener">projectcalico.docs.tigera.io/about/</a></p></blockquote><p>在这里使用 calico 来做为集群的网络插件，官网提供2种安装方式：</p><ul><li>operator 的方式修改镜像比较麻烦，这里不使用；</li><li>通过yaml配置文件的方式；</li></ul><pre><code class="bash">curl https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/calico.yaml -O</code></pre><p><strong>配置：</strong></p><ul><li><strong>修改 <code>CALICO_IPV4POOL_CIDR</code> 为我们的网段（本文为：<code>10.254.0.0/16</code>）</strong></li><li><strong>修改 <code>CALICO_IPV4POOL_IPIP</code> 为 <code>Always</code> 启用 ipip 协议；</strong></li></ul><pre><code class="diff">- # - name: CALICO_IPV4POOL_CIDR- #   value: &quot;192.168.0.0/16&quot;+ - name: CALICO_IPV4POOL_CIDR+   value: &quot;10.254.0.0/16&quot;# Enable IPIP+ - name: CALICO_IPV4POOL_IPIP+   value: &quot;Always&quot;</code></pre><p><strong>修改镜像地址：</strong></p><p>搜索 <code>image:</code> 将镜像修改：</p><pre><code class="diff">- image: docker.io/calico/cni:v3.28.1+ image: registry.cn-hangzhou.aliyuncs.com/jasonkay/cni:v3.28.1- image: docker.io/calico/node:v3.28.1+ image: registry.cn-hangzhou.aliyuncs.com/jasonkay/node:v3.28.1- image: docker.io/calico/kube-controllers:v3.28.1+ image: registry.cn-hangzhou.aliyuncs.com/jasonkay/kube-controllers:v3.28.1</code></pre><blockquote><p>  <strong>即，将：<code>docker.io/calico</code> 替换为 <code>registry.cn-hangzhou.aliyuncs.com/jasonkay</code> （我在阿里云上同步的镜像）！</strong></p></blockquote><p>随后执行：</p><pre><code class="bash">kubectl apply -f calico.yaml</code></pre><p>等待部署完成即可！</p><br><h3 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a><strong>2、验证</strong></h3><p>验证 coredns dns 转发是否正常：</p><pre><code class="bash"># 安装dns工具apt install -y dnsutils# 获取dns ip地址kubectl get svc -n kube-systemNAME       TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                  AGEkube-dns   ClusterIP   10.254.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   15h# 测试能够解析dig -t a www.baidu.com @10.254.0.10</code></pre><br><h2 id="四、部署应用测试"><a href="#四、部署应用测试" class="headerlink" title="四、部署应用测试"></a><strong>四、部署应用测试</strong></h2><p>部署 nginx 进行测试：</p><p>nginx-deploy.yaml</p><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: registry.cn-hangzhou.aliyuncs.com/jasonkay/nginx:latest        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-servicespec:  type: NodePort  selector:    app: nginx  ports:    - protocol: TCP      port: 80      targetPort: 80      nodePort: 31080</code></pre><p>应用：</p><pre><code class="bash">kubectl apply -f nginx-deploy.yaml</code></pre><p>然后访问 <code>k8s-ip:31080</code>，能够正常访问 Nginx！</p><br><h2 id="五、安装Helm"><a href="#五、安装Helm" class="headerlink" title="五、安装Helm"></a><strong>五、安装Helm</strong></h2><p>Helm 是 Kubernetes 的一个包管理工具，类似于 Linux 的 Apt 或 Yum；</p><p>这个工具能帮助开发者和系统管理员更方便地管理在 Kubernetes 集群上部署、更新、卸载应用。</p><p><code>Helm</code> 中的三个主要概念：</p><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>Chart</td><td>在 Kubernetes 集群上部署应用所需的所有资源定义的包</td></tr><tr><td>Release</td><td>在 Kubernetes 集群上部署的 Chart 的实例</td></tr><tr><td>Repository</td><td>Chart 的存储位置，类似软件仓库，用于分发和分享 Chart</td></tr></tbody></table><p>安装脚本：</p><pre><code class="bash">1. 添加 Helm 的官方 GPG keyroot@k8s-master:~# curl https://baltocdn.com/helm/signing.asc | gpg --dearmor -o /usr/share/keyrings/helm-keyring.gpg2. 添加 Helm 的官方 APT 仓库root@k8s-master:~# echo &quot;deb [signed-by=/usr/share/keyrings/helm-keyring.gpg] https://baltocdn.com/helm/stable/debian/ all main&quot; | tee /etc/apt/sources.list.d/helm-stable-debian.list3. 更新 apt 源root@k8s-master:~# apt-get update4. 安装 Helmroot@k8s-master:~# apt-get install -y helm5. 检查 Helm 是否已正确安装root@k8s-master:~# helm versionversion.BuildInfo{Version:&quot;v3.13.3&quot;, GitCommit:&quot;c8b948945e52abba22ff885446a1486cb5fd3474&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.20.11&quot;}</code></pre><br><h2 id="六、安装面板KubeSphere"><a href="#六、安装面板KubeSphere" class="headerlink" title="六、安装面板KubeSphere"></a><strong>六、安装面板KubeSphere</strong></h2><p>官方提供的面板不太好用，这里推荐使用 KubeSphere；</p><p>配置下载区域：</p><pre><code class="bash">export KKZONE=cn</code></pre><p>安装也很简单，使用 helm 即可，而且支持国内：</p><pre><code class="bash">helm upgrade --install -n kubesphere-system \  --create-namespace ks-core \  https://charts.kubesphere.com.cn/main/ks-core-1.1.4.tgz \  --debug --wait \  --set global.imageRegistry=swr.cn-southwest-2.myhuaweicloud.com/ks \  --set extension.imageRegistry=swr.cn-southwest-2.myhuaweicloud.com/ks</code></pre><p>等待所有 Pod 就绪后，安装完成，显示：</p><pre><code>NOTES:Thank you for choosing KubeSphere Helm Chart.Please be patient and wait for several seconds for the KubeSphere deployment to complete.1. Wait for Deployment Completion    Confirm that all KubeSphere components are running by executing the following command:    kubectl get pods -n kubesphere-system2. Access the KubeSphere Console    Once the deployment is complete, you can access the KubeSphere console using the following URL:    http://192.168.6.10:308803. Login to KubeSphere Console    Use the following credentials to log in:    Account: admin    Password: P@88w0rdNOTE: It is highly recommended to change the default password immediately after the first login.For additional information and details, please visit https://kubesphere.io.</code></pre><p>执行以下命令检查 Pod 状态。</p><pre><code>kubectl get pods -n kubesphere-system</code></pre><p>当 Pod 状态都为 <strong>Running</strong> 时，使用默认的账户和密码 (admin/P@88w0rd) 通过 <code>&lt;NodeIP&gt;:30880</code> 访问 KubeSphere Web 控制台！</p><br><h2 id="七、工具推荐"><a href="#七、工具推荐" class="headerlink" title="七、工具推荐"></a><strong>七、工具推荐</strong></h2><h3 id="1、kubectx"><a href="#1、kubectx" class="headerlink" title="1、kubectx"></a><strong>1、kubectx</strong></h3><p>推荐安装 kubectx，可以切换k8s上下文（管理多个集群）；</p><p>并且 kubectx 自带了另一个工具：kubens，可以方便切换默认的 namespace；</p><p>安装：</p><pre><code class="bash">apt install -y kubectx</code></pre><br><h3 id="2、nerdctl"><a href="#2、nerdctl" class="headerlink" title="2、nerdctl"></a><strong>2、nerdctl</strong></h3><p>nerdctl 可以提供在宿主机上类 docker 的操作（操作 containerd），可以提升用户体验：</p><pre><code class="bash">cd /tmpwget https://github.com/containerd/nerdctl/releases/download/v1.7.6/nerdctl-1.7.6-linux-amd64.tar.gztar xf nerdctl-1.7.6-linux-amd64.tar.gzmv nerdctl /usr/sbin</code></pre><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>参考文章：</p><ul><li><a href="https://isekiro.com/kubernetes%E5%9F%BA%E7%A1%80-debian-%E9%83%A8%E7%BD%B2k8s-1.28/" target="_blank" rel="noopener">https://isekiro.com/kubernetes%E5%9F%BA%E7%A1%80-debian-%E9%83%A8%E7%BD%B2k8s-1.28/</a></li><li><a href="https://juejin.cn/post/7300419978486169641" target="_blank" rel="noopener">https://juejin.cn/post/7300419978486169641</a></li><li><a href="https://www.cnblogs.com/5201351/p/17407406.html" target="_blank" rel="noopener">https://www.cnblogs.com/5201351/p/17407406.html</a></li><li><a href="https://kubesphere.io/zh/docs/v4.1/02-quickstart/01-install-kubesphere/" target="_blank" rel="noopener">https://kubesphere.io/zh/docs/v4.1/02-quickstart/01-install-kubesphere/</a></li></ul><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/kubernetes-learn" target="_blank" rel="noopener">https://github.com/JasonkayZK/kubernetes-learn</a></li></ul><br>]]></content>
    
    
    <summary type="html">由于暑假到了以及天气原因，学校的k8s集群暂时关闭了，但是目前还是有使用k8s的需求，花了2个小时又重新搭了一下。由于国内网络的问题，导致github包、镜像都很难拉下来，因此本文的内容更适合国内需求环境。</summary>
    
    
    
    <category term="Kubernetes" scheme="https://jasonkayzk.github.io/categories/Kubernetes/"/>
    
    
    <category term="VMWare" scheme="https://jasonkayzk.github.io/tags/VMWare/"/>
    
    <category term="Kubernetes" scheme="https://jasonkayzk.github.io/tags/Kubernetes/"/>
    
    <category term="Debian" scheme="https://jasonkayzk.github.io/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>分享两个服务器实用脚本：xsync和xcall</title>
    <link href="https://jasonkayzk.github.io/2025/07/21/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC%EF%BC%9Axsync%E5%92%8Cxcall/"/>
    <id>https://jasonkayzk.github.io/2025/07/21/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC%EF%BC%9Axsync%E5%92%8Cxcall/</id>
    <published>2025-07-21T02:20:51.000Z</published>
    <updated>2025-07-30T10:34:36.215Z</updated>
    
    <content type="html"><![CDATA[<p>如果同时需要维护多台服务器，可能会需要在多台服务器之间同步文件、执行命令。</p><p>本文介绍了两个简单的脚本实现这一功能！</p><p>源代码：</p><ul><li><a href="https://gist.github.com/JasonkayZK/e8bbe840d4b4d9d0ed15d4385e1c0a07" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/e8bbe840d4b4d9d0ed15d4385e1c0a07</a></li><li><a href="https://gist.github.com/JasonkayZK/6847064a739bd08232e2da938d5e34ef" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/6847064a739bd08232e2da938d5e34ef</a></li></ul><br><a id="more"></a><h1 id="分享两个服务器实用脚本：xsync和xcall"><a href="#分享两个服务器实用脚本：xsync和xcall" class="headerlink" title="分享两个服务器实用脚本：xsync和xcall"></a><strong>分享两个服务器实用脚本：xsync和xcall</strong></h1><h2 id="文件同步：xsync"><a href="#文件同步：xsync" class="headerlink" title="文件同步：xsync"></a><strong>文件同步：xsync</strong></h2><h3 id="1、前置依赖"><a href="#1、前置依赖" class="headerlink" title="1、前置依赖"></a><strong>1、前置依赖</strong></h3><p>xsync 依赖于 rsync 工具，可以通过 yum 或者 apt 简单的安装：</p><pre><code class="bash">apt或yum install -y rsync</code></pre><p><strong>此外，还需要配置 SSH 无密码登录！</strong></p><br><h3 id="2、编写脚本"><a href="#2、编写脚本" class="headerlink" title="2、编写脚本"></a><strong>2、编写脚本</strong></h3><p>脚本内容：</p><p>xsync</p><pre><code class="bash">#!/bin/bash# Dependency:#  1. rsync: yum/apt install -y rsync#  2. password-less SSH login## 0. Define server listservers=(&quot;server-1&quot; &quot;server-2&quot; &quot;server-3&quot;)# 1. check param numif [ $# -lt 1 ]; then  echo &quot;Not Enough Arguement!&quot;  exit 1fi# 2. traverse all machinesfor host in &quot;${servers[@]}&quot;; do  echo &quot;====================  $host  ====================&quot;  # 3. traverse dir for each file  for file in &quot;$@&quot;; do    # 4. check file exist    if [ -e &quot;$file&quot; ]; then      # 5. get parent dir      pdir=$(cd -P &quot;$(dirname &quot;$file&quot;)&quot; &amp;&amp; pwd)      # 6. get file name      fname=$(basename &quot;$file&quot;)      ssh &quot;$host&quot; &quot;mkdir -p $pdir&quot;      rsync -av &quot;$pdir/$fname&quot; &quot;$host:$pdir&quot;    else      echo &quot;$file does not exist!&quot;    fi  donedone</code></pre><blockquote><p>  <strong>使用时，上面的文件中 servers 数组中的配置，为你服务器集群！</strong></p></blockquote><br><h3 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a><strong>3、使用</strong></h3><p>增加可执行权限、并将文件放在 PATH 下；</p><p>然后直接使用，例如：</p><pre><code class="bash">xsync ~/.bashrc</code></pre><br><h2 id="命令执行：xcall"><a href="#命令执行：xcall" class="headerlink" title="命令执行：xcall"></a><strong>命令执行：xcall</strong></h2><p>和 xsync 类似，编写：</p><p>xcall</p><pre><code class="bash">#!/bin/bash# Dependency: password-less SSH login## Define server array (easily extensible)servers=(  &quot;server-1&quot;  &quot;server-2&quot;  &quot;server-3&quot;)# Check if command arguments are providedif [ $# -eq 0 ]; then  echo &quot;Error: Please provide a command to execute&quot; &gt;&amp;2  exit 1fi# Execute command across all serversfor server in &quot;${servers[@]}&quot;; do  echo &quot;--------- $server ----------&quot;  # Execute remote command and handle errors  if ssh &quot;$server&quot; &quot;$*&quot;; then    echo &quot;✓ Command executed successfully&quot;  else    echo &quot;✗ Command failed on server: $server&quot; &gt;&amp;2    # Uncomment below line to exit script on first failure    # exit 1  fidone</code></pre><p>使用也是类似：</p><p>增加可执行权限、并将文件放在 PATH 下；</p><p>然后直接使用，例如：</p><pre><code class="bash">xcall ls</code></pre><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://gist.github.com/JasonkayZK/e8bbe840d4b4d9d0ed15d4385e1c0a07" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/e8bbe840d4b4d9d0ed15d4385e1c0a07</a></li><li><a href="https://gist.github.com/JasonkayZK/6847064a739bd08232e2da938d5e34ef" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/6847064a739bd08232e2da938d5e34ef</a></li></ul><br>]]></content>
    
    
    <summary type="html">如果同时需要维护多台服务器，可能会需要在多台服务器之间同步文件、执行命令。本文介绍了两个简单的脚本实现这一功能！</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
  </entry>
  
  <entry>
    <title>RSS订阅工具Folo使用</title>
    <link href="https://jasonkayzk.github.io/2025/07/15/RSS%E8%AE%A2%E9%98%85%E5%B7%A5%E5%85%B7Folo%E4%BD%BF%E7%94%A8/"/>
    <id>https://jasonkayzk.github.io/2025/07/15/RSS%E8%AE%A2%E9%98%85%E5%B7%A5%E5%85%B7Folo%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-15T13:30:21.000Z</published>
    <updated>2025-07-30T10:34:36.198Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直使用的是Inoreader，也早就听说并且下载了Folo，但是一直没有时间切换；</p><p>今天有时间切换到了Folo，聊一下感受！</p><p>源代码：</p><ul><li><a href="https://github.com/RSSNext/Folo" target="_blank" rel="noopener">https://github.com/RSSNext/Folo</a></li></ul><br><a id="more"></a><h1 id="RSS订阅工具Folo使用"><a href="#RSS订阅工具Folo使用" class="headerlink" title="RSS订阅工具Folo使用"></a><strong>RSS订阅工具Folo使用</strong></h1><h2 id="零、Folo介绍"><a href="#零、Folo介绍" class="headerlink" title="零、Folo介绍"></a><strong>零、Folo介绍</strong></h2><p>Follow 是一款新兴且创新的 RSS 订阅工具；</p><p>除了具备传统 RSS 订阅器的所有基本功能外，Follow 还提供了一些额外的特色功能。</p><p>类似于 Inoreader，可以订阅 RSS，查看属于自己独一无二的信息流；</p><blockquote><p>  <strong>如果你还不了解 RSS，可以简单认为类似于将网页内容转为微信公众号订阅！</strong></p></blockquote><br><h2 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a><strong>一、使用方法</strong></h2><h3 id="1、下载-amp-注册"><a href="#1、下载-amp-注册" class="headerlink" title="1、下载&amp;注册"></a><strong>1、下载&amp;注册</strong></h3><p>Web 版：</p><ul><li><a href="https://app.follow.is/" target="_blank" rel="noopener">https://app.follow.is/</a></li></ul><p>Mac、Win、Android：</p><ul><li><a href="https://github.com/RSSNext/Folo/releases" target="_blank" rel="noopener">https://github.com/RSSNext/Folo/releases</a></li></ul><br><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a><strong>2、使用</strong></h3><p>添加订阅即可！</p><p>添加方法：</p><ul><li>（1）搜索：输入关键词进行搜索；</li><li>（2）RSS订阅：输入RSS URL进行订阅；</li><li>（3）RSSHub订阅；</li><li>（4）RSS3</li></ul><ol start="5"><li>（5）UID：可以直接搜索订阅正在使用Follow的用户，输入对方的UID（在个人资料里设置的唯一标识）即可订阅；</li></ol><ul><li>（6）通过导入OPML文件（如Inoreader）订阅；</li></ul><blockquote><p>  <strong>强烈建议配合RSSHub使用（网页插件，可以探索当前页面的RSS源）：</strong></p><ul><li><a href="https://docs.rsshub.app/" target="_blank" rel="noopener">https://docs.rsshub.app/</a></li></ul></blockquote><br><h2 id="二、从Inoreader迁移"><a href="#二、从Inoreader迁移" class="headerlink" title="二、从Inoreader迁移"></a><strong>二、从Inoreader迁移</strong></h2><p>如果你根据 Folo 提供的：</p><pre><code>打开 https://www.inoreader.com/preferences/content切换到 &quot;SYSTEM FOLDERS&quot; 标签。点击 &quot;Newsfeed&quot; 右侧的 &quot;OPML&quot; 按钮。</code></pre><p>会要求你开通会员才能导出；</p><p>可以在设置的 <code>账号</code> 中，选择 <code>导出和备份</code>，此时会导出 xml 格式的文件！</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/inoreader-export-1.jpg" alt="inoreader-export-1.jpg"></p><p>随后，在导入时选择 <code>所有文件</code>，即可导入！</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/inoreader-export-2.jpg" alt="inoreader-export-2.jpg"></p><blockquote><p>  <strong>目前最多支持500个订阅，比 Inoreader 的150 个多很多了！</strong></p></blockquote><br><h2 id="三、RSS所有者认证"><a href="#三、RSS所有者认证" class="headerlink" title="三、RSS所有者认证"></a><strong>三、RSS所有者认证</strong></h2><p>认证自己的订阅源。</p><h3 id="1、获取认证码"><a href="#1、获取认证码" class="headerlink" title="1、获取认证码"></a><strong>1、获取认证码</strong></h3><p>你在 Follow 中订阅自己的博客，再在 Follow 中右键点击订阅源，申请 Claim，便可以获取到认证码，例如：</p><p>This message is used to verify that this feed (feedId:57983956538829824) belongs to me (userId:81890745999218688). Join me in enjoying the next generation information browser <a href="https://folo.is" target="_blank" rel="noopener">https://folo.is</a>.</p><h3 id="2、验证认证码"><a href="#2、验证认证码" class="headerlink" title="2、验证认证码"></a><strong>2、验证认证码</strong></h3><p>在你的博客，写入一篇文章，贴入认证码并发布；然后在 Follow 中再次申请 Claim 即可认证。 认证过后，认证码的信息便可以删除；此处予以修改、保留，方便其他读者认证时参考使用。 </p><p>当然，你也可以通过一个 Telegram 频道，来进行 Follow 的认证。</p><br><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h2><p>更多的内容可以阅读：</p><ul><li><a href="https://yinji.org/5317.html" target="_blank" rel="noopener">《使用 Follow 的第 50 天：RSS 迎来又一春？》</a></li></ul><p>后续也会在博客分享一些我的订阅源，敬请期待～</p><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://github.com/RSSNext/Folo" target="_blank" rel="noopener">https://github.com/RSSNext/Folo</a></li></ul><p>RSS相关服务：</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//docs.rsshub.app/" target="_blank" rel="noopener">RSSHub</a></li><li><a href="https://link.zhihu.com/?target=https%3A//tg.i-c-a.su/" target="_blank" rel="noopener">Telegram RSS / JSON generator</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/damoeb/rss-proxy" target="_blank" rel="noopener">RSS-proxy</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/firmianay/yarb" target="_blank" rel="noopener">yarb (Yet Another Rss Bot)</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/aboutrss/ALL-about-RSS" target="_blank" rel="noopener">ALL-about-RSS</a></li><li><a href="https://link.zhihu.com/?target=https%3A//rss.lilydjwg.me/" target="_blank" rel="noopener">各种转 RSS 服务</a></li><li><a href="https://link.zhihu.com/?target=https%3A//diff.blog/" target="_blank" rel="noopener">diff.blog</a></li><li><a href="https://link.zhihu.com/?target=https%3A//kill-the-newsletter.com/" target="_blank" rel="noopener">Kill the Newsletter</a></li></ul><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/781349659" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/781349659</a></li><li><a href="https://yinji.org/5317.html" target="_blank" rel="noopener">https://yinji.org/5317.html</a></li></ul><br>]]></content>
    
    
    <summary type="html">之前一直使用的是Inoreader，也早就听说并且下载了Folo，但是一直没有时间切换。今天有时间切换到了Folo，聊一下感受！</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="RSS" scheme="https://jasonkayzk.github.io/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>多平台消息推送工具ntfy使用</title>
    <link href="https://jasonkayzk.github.io/2025/07/15/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%B7%A5%E5%85%B7ntfy%E4%BD%BF%E7%94%A8/"/>
    <id>https://jasonkayzk.github.io/2025/07/15/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%B7%A5%E5%85%B7ntfy%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-15T08:52:51.000Z</published>
    <updated>2025-07-30T10:34:36.218Z</updated>
    
    <content type="html"><![CDATA[<p>ntfy是一个开源的多平台消息推送工具，可以通过HTTP请求发送通知到手机或桌面。</p><p>本文总结了ntfy的安装、配置和使用方法。</p><p>官方仓库：</p><ul><li><a href="https://github.com/binwiederhier/ntfy" target="_blank" rel="noopener">https://github.com/binwiederhier/ntfy</a></li></ul><br><a id="more"></a><h1 id="ntfy使用"><a href="#ntfy使用" class="headerlink" title="ntfy使用"></a><strong>ntfy使用</strong></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>ntfy（发音为“notify”）是一个简单的基于HTTP的发布-订阅通知服务。通过ntfy，可以使用PUT/POST请求从任何计算机的脚本发送通知到手机或桌面，而无需注册或支付费用。</p><p>同时ntfy是开源的，可以轻松自托管。</p><p>ntfy提供免费的公共实例：ntfy.sh，也有Android和iOS应用可用；</p><p>主要特点：</p><ul><li><strong>简单易用</strong>：通过curl等工具发送通知。</li><li><strong>自托管</strong>：可以部署自己的实例。</li><li><strong>多平台</strong>：支持Android、iOS、Web等。</li><li><strong>访问控制</strong>：支持用户认证和ACL。</li></ul><br><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a><strong>二、使用</strong></h2><h3 id="1、发送通知"><a href="#1、发送通知" class="headerlink" title="1、发送通知"></a><strong>1、发送通知</strong></h3><p>使用curl：</p><pre><code class="bash">curl -d &quot;Hello from ntfy&quot; ntfy.sh/mytopic</code></pre><h3 id="2、订阅主题"><a href="#2、订阅主题" class="headerlink" title="2、订阅主题"></a><strong>2、订阅主题</strong></h3><p>在APP或Web订阅主题接收通知。</p><br><h2 id="三、自部署"><a href="#三、自部署" class="headerlink" title="三、自部署"></a><strong>三、自部署</strong></h2><p>参考：</p><ul><li><a href="https://blog.xiaoz.org/archives/20400" target="_blank" rel="noopener">https://blog.xiaoz.org/archives/20400</a></li><li><a href="https://k1r.in/posts/notify-ntfy/" target="_blank" rel="noopener">https://k1r.in/posts/notify-ntfy/</a></li></ul><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>参考：</p><ul><li><a href="https://github.com/binwiederhier/ntfy" target="_blank" rel="noopener">https://github.com/binwiederhier/ntfy</a></li><li><a href="https://k1r.in/posts/notify-ntfy/" target="_blank" rel="noopener">https://k1r.in/posts/notify-ntfy/</a></li><li><a href="https://blog.7theaven.top/2023/06/11/%E4%BD%BF%E7%94%A8-ntfy-%E8%87%AA%E5%BB%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/#toc-head-1" target="_blank" rel="noopener">https://blog.7theaven.top/2023/06/11/%E4%BD%BF%E7%94%A8-ntfy-%E8%87%AA%E5%BB%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/#toc-head-1</a></li><li><a href="https://blog.xiaoz.org/archives/20400" target="_blank" rel="noopener">https://blog.xiaoz.org/archives/20400</a></li></ul><br>]]></content>
    
    
    <summary type="html">ntfy是一个开源的多平台消息推送工具，可以通过HTTP请求发送通知到手机或桌面。本文总结了ntfy的安装、配置和使用方法。</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="推送" scheme="https://jasonkayzk.github.io/tags/推送/"/>
    
    <category term="ntfy" scheme="https://jasonkayzk.github.io/tags/ntfy/"/>
    
  </entry>
  
  <entry>
    <title>AppleScript介绍与简单实战</title>
    <link href="https://jasonkayzk.github.io/2025/07/15/AppleScript%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/"/>
    <id>https://jasonkayzk.github.io/2025/07/15/AppleScript%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/</id>
    <published>2025-07-15T06:23:25.000Z</published>
    <updated>2025-07-30T10:34:36.181Z</updated>
    
    <content type="html"><![CDATA[<p>AppleScript是macOS内置的脚本语言，可以自动化操作应用程序。本文介绍了AppleScript的基本概念、语法和一个简单实战示例。</p><br><a id="more"></a><h1 id="AppleScript介绍与简单实战"><a href="#AppleScript介绍与简单实战" class="headerlink" title="AppleScript介绍与简单实战"></a><strong>AppleScript介绍与简单实战</strong></h1><h2 id="一、什么是AppleScript"><a href="#一、什么是AppleScript" class="headerlink" title="一、什么是AppleScript"></a><strong>一、什么是AppleScript</strong></h2><p>AppleScript是苹果公司推出的一种脚本语言，内置于macOS中，可以直接操作和控制macOS及其应用程序。它是一个实现macOS自动化的强大工具，AppleScript的前身是HyperCard所使用的脚本语言HyperTalk。</p><p>与其他脚本语言如Python和JavaScript相比，AppleScript最显著的特点是能够控制其他macOS上的应用程序。通过AppleScript，我们可以完成一些繁琐重复的工作。其语法简单，接近自然语言，就像在和系统对话一样。此外，系统提供了语法查询字典，方便查询语法。</p><br><h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><p>按照惯例，用AppleScript写一个Hello World：</p><pre><code class="applescript">display dialog &quot;Hello, world!&quot;</code></pre><p>命令行执行：</p><pre><code class="bash">osascript -e &#39;display dialog &quot;Hello, world!&quot;&#39;</code></pre><p>运行后，系统会弹出“Hello, world!”的弹窗。</p><br><p>下面介绍几种常用语法：</p><h3 id="1、告诉应用做某事"><a href="#1、告诉应用做某事" class="headerlink" title="1、告诉应用做某事"></a><strong>1、告诉应用做某事</strong></h3><p>AppleScript的语法接近自然语言，例如：</p><pre><code class="applescript">tell application &quot;Safari&quot;    activate    open location &quot;https://qq.com/&quot;end tell</code></pre><p>这告诉Safari启动并打开指定网址。</p><h3 id="2、设置变量"><a href="#2、设置变量" class="headerlink" title="2、设置变量"></a><strong>2、设置变量</strong></h3><pre><code class="applescript">set qq to &quot;https://qq.com/&quot;tell application &quot;Safari&quot;    activate    open location qqend tell</code></pre><br><h3 id="3、条件语句"><a href="#3、条件语句" class="headerlink" title="3、条件语句"></a><strong>3、条件语句</strong></h3><pre><code class="applescript">if num &gt; 2 then    // ...else    // ...end if</code></pre><br><h3 id="4、循环语句"><a href="#4、循环语句" class="headerlink" title="4、循环语句"></a><strong>4、循环语句</strong></h3><pre><code class="applescript">repeat with num in {1, 2, 3}    display dialog &quot;hello, world&quot;end repeat</code></pre><br><h3 id="5、模拟点击和输入"><a href="#5、模拟点击和输入" class="headerlink" title="5、模拟点击和输入"></a><strong>5、模拟点击和输入</strong></h3><p>可以使用<code>click</code>命令模拟点击，或<code>keystroke</code>输入文本。</p><br><h2 id="三、简单实战：命令完成后显示通知"><a href="#三、简单实战：命令完成后显示通知" class="headerlink" title="三、简单实战：命令完成后显示通知"></a><strong>三、简单实战：命令完成后显示通知</strong></h2><p>执行以下命令可以展示一条通知：</p><pre><code class="bash">osascript -e &#39;display notification &quot;The command finished&quot; with title &quot;Success&quot;&#39;</code></pre><p>在.zshrc中定义一个函数：</p><pre><code class="bash">function notifyResult () {  if [ $? -eq 0 ]; then    osascript -e &#39;display notification &quot;The command finished&quot; with title &quot;Success&quot;&#39;  else    osascript -e &#39;display notification &quot;The command failed&quot; with title &quot;Failed&quot;&#39;  fi}</code></pre><p>运行长时间命令时：</p><pre><code class="bash">some_program; notifyResult</code></pre><p>执行完后会收到通知是否执行成功！</p><blockquote><p>  可以设置通知音效：</p><ul><li><a href="https://strdr4605.com/mac-os-notify-when-the-terminal-command-is-finished" target="_blank" rel="noopener">MacOS: notify when the terminal command is finished</a></li></ul></blockquote><br><h2 id="四、一些常用脚本"><a href="#四、一些常用脚本" class="headerlink" title="四、一些常用脚本"></a><strong>四、一些常用脚本</strong></h2><h3 id="1、通过参数发送系统通知"><a href="#1、通过参数发送系统通知" class="headerlink" title="1、通过参数发送系统通知"></a><strong>1、通过参数发送系统通知</strong></h3><blockquote><p>  源代码：</p><ul><li><a href="https://gist.github.com/JasonkayZK/c32cc4af8582b12d785619f6c999999f" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/c32cc4af8582b12d785619f6c999999f</a></li></ul></blockquote><p>代码如下：</p><p>sys-notify</p><pre><code class="bash">#!/bin/bash# 帮助函数show_help() {    echo &quot;Usage: $0 [Option] [message]&quot;    echo &quot;Show system notification&quot;    echo    echo &quot;Option:&quot;    echo &quot;  -h, --help         Show help info&quot;    echo &quot;  -t, --title TITLE  Set notification title (Default: Notify)&quot;    exit 0}# 默认值title=&quot;Notify&quot;# 解析命令行参数while [[ $# -gt 0 ]]; do    case &quot;$1&quot; in        -h|--help)            show_help            ;;        -t|--title)            if [[ -z &quot;$2&quot; ]]; then                echo &quot;错误: --title 需要一个参数&quot; &gt;&amp;2                exit 1            fi            title=&quot;$2&quot;            shift 2            ;;        *)            # 第一个非选项参数视为消息内容            message=&quot;$1&quot;            shift            break            ;;    esacdone# 如果没有提供消息内容，则从标准输入读取if [[ -z &quot;$message&quot; ]]; then    if [[ -t 0 ]]; then        echo &quot;错误: 没有提供消息内容&quot; &gt;&amp;2        show_help        exit 1    else        message=$(cat)    fifi# 发送通知case &quot;$(uname -s)&quot; in    Darwin)        # macOS 使用 AppleScript        osascript -e &quot;display notification \&quot;$message\&quot; with title \&quot;$title\&quot;&quot;        ;;    Linux)        # Linux 使用 notify-send (libnotify)        if command -v notify-send &amp;&gt;/dev/null; then            notify-send &quot;$title&quot; &quot;$message&quot;        else            echo &quot;错误: 未找到 notify-send 命令。请安装 libnotify 包。&quot; &gt;&amp;2            exit 1        fi        ;;    *)        echo &quot;错误: 不支持的操作系统&quot; &gt;&amp;2        exit 1        ;;esac    </code></pre><p>准备：</p><ul><li>编写 <code>sys-notify</code>；</li><li>增加可执行权限 <code>chmod +x sys-notify</code>；</li><li>加入到 PATH 环境变量；</li></ul><p>使用方法：</p><ul><li>基本用法：<code>sys-notify &quot;操作已完成&quot;</code></li><li>自定义标题：<code>sys-notify -t &quot;操作结果&quot; &quot;操作已完成&quot;</code></li><li>从标准输入读取内容：<code>echo &quot;操作已完成&quot; | sys-notify -t &quot;操作结果&quot;</code></li></ul><br><h3 id="2、命令完成后展示结果"><a href="#2、命令完成后展示结果" class="headerlink" title="2、命令完成后展示结果"></a><strong>2、命令完成后展示结果</strong></h3><blockquote><p>  源代码：</p><ul><li><a href="https://gist.github.com/JasonkayZK/d5c4e3adadf3478ded5896becf01f08c" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/d5c4e3adadf3478ded5896becf01f08c</a></li></ul></blockquote><pre><code class="bash">function notifyResult () {  if [ $? -eq 0 ]; then    osascript -e &#39;display notification &quot;The command finished&quot; with title &quot;Success&quot;&#39;  else    osascript -e &#39;display notification &quot;The command failed&quot; with title &quot;Failed&quot;&#39;  fi}</code></pre><p>在运行某些需要比较长时间的程序时，执行以下命令：</p><pre><code class="node-repl">some_program; notifyResult</code></pre><br><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a><strong>五、后记</strong></h2><p>AppleScript是一个简单而强大的工具，能自动化macOS操作；</p><p>更多内容可参考附录链接；</p><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://gist.github.com/JasonkayZK/c32cc4af8582b12d785619f6c999999f" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/c32cc4af8582b12d785619f6c999999f</a></li><li><a href="https://gist.github.com/JasonkayZK/d5c4e3adadf3478ded5896becf01f08c" target="_blank" rel="noopener">https://gist.github.com/JasonkayZK/d5c4e3adadf3478ded5896becf01f08c</a></li></ul><p>官方文档：</p><ul><li><a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html</a></li></ul><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/149893274" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/149893274</a></li><li><a href="https://ameow.xyz/archives/display-notification-after-command-finishes-macos" target="_blank" rel="noopener">https://ameow.xyz/archives/display-notification-after-command-finishes-macos</a></li></ul><br>]]></content>
    
    
    <summary type="html">AppleScript是MacOS内置的脚本语言，可以自动化操作应用程序。本文介绍了AppleScript的基本概念、语法和一个简单实战示例。</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="AppleScript" scheme="https://jasonkayzk.github.io/tags/AppleScript/"/>
    
    <category term="MacOS" scheme="https://jasonkayzk.github.io/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>uv使用</title>
    <link href="https://jasonkayzk.github.io/2025/07/14/uv%E4%BD%BF%E7%94%A8/"/>
    <id>https://jasonkayzk.github.io/2025/07/14/uv%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-14T06:02:30.000Z</published>
    <updated>2025-07-30T10:34:36.205Z</updated>
    
    <content type="html"><![CDATA[<p><code>uv</code> 是一个用 Rust 编写的、速度极快的 Python 包和项目管理工具，由 <code>ruff</code> 的作者开发。它的目标是成为 <code>pip</code>、<code>venv</code>、<code>virtualenv</code> 和 <code>pip-tools</code> 等工具的直接替代品，提供一个统一、快速且易于使用的体验。</p><p>本文总结了如何安装和使用 <code>uv</code>。</p><p>官方仓库：</p><ul><li><a href="https://github.com/astral-sh/uv" target="_blank" rel="noopener">https://github.com/astral-sh/uv</a></li></ul><br><a id="more"></a><h1 id="uv使用"><a href="#uv使用" class="headerlink" title="uv使用"></a><strong>uv使用</strong></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>如果你对 Python 的包管理生态有所了解，你可能用过 <code>pip</code> 来安装包，用 <code>venv</code> 或 <code>virtualenv</code> 来创建虚拟环境，用 <code>pip-tools</code> 来锁定依赖。这些工具各司其职，但组合使用起来有时会显得有些繁琐。</p><p><code>uv</code> 的出现就是为了解决这个问题。它将包安装、虚拟环境管理和依赖解析等功能集成到了一个单一的命令行工具中，并且性能极高。</p><p><strong>主要特点：</strong></p><ul><li><strong>极速：</strong> <code>uv</code> 利用了先进的依赖解析算法和全局缓存，安装和解析包的速度比 <code>pip</code> 快得多。</li><li><strong>一体化：</strong> 无需在 <code>pip</code> 和 <code>venv</code> 之间切换，<code>uv</code> 提供了统一的命令来处理大多数包和环境管理任务。</li><li><strong>直接替代：</strong> <code>uv</code> 的命令设计与 <code>pip</code> 非常相似（例如 <code>uv pip install</code>），使得迁移成本非常低。</li><li><strong>依赖锁定：</strong> 内置了类似 <code>pip-tools</code> 的功能，可以从 <code>pyproject.toml</code> 或 <code>requirements.in</code> 文件编译生成锁定的 <code>requirements.txt</code> 文件。</li></ul><br><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a><strong>二、安装</strong></h2><p><code>uv</code> 提供了多种安装方式：</p><h4 id="macOS-和-Linux"><a href="#macOS-和-Linux" class="headerlink" title="macOS 和 Linux"></a><strong>macOS 和 Linux</strong></h4><p>使用 <code>curl</code>:</p><pre><code class="bash">curl -LsSf https://astral.sh/uv/install.sh | sh</code></pre><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h4><p>使用 PowerShell:</p><pre><code class="bash">powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</code></pre><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a><strong>其他方式</strong></h4><p>也可以通过 <code>pip</code>、<code>brew</code> 等包管理器安装：</p><pre><code class="bash"># 通过 pippip install uv# 通过 Homebrewbrew install uv</code></pre><p>安装完成后，可以通过 <code>uv --version</code> 来验证是否成功。</p><br><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a><strong>三、基本使用</strong></h2><p><code>uv</code> 的使用非常直观，特别是对于熟悉 <code>pip</code> 和 <code>venv</code> 的用户。</p><h3 id="1、管理python版本"><a href="#1、管理python版本" class="headerlink" title="1、管理python版本"></a><strong>1、管理python版本</strong></h3><p>使用如下命令，显示出当前环境中所有可用的python版本（包括已经安装的和可以安装的）</p><pre><code class="bash">uv python list</code></pre><p>如果需要安装其他版本的python，使用如下命令</p><pre><code>uv python install 3.12</code></pre><p>除了标准python之外，还可以安装其他的Python实现，比如PyPy实现的python：</p><pre><code class="sh">uv python install pypy@3.10</code></pre><p>查找某个python版本的路径：</p><pre><code class="sh">❯ uv python find 3.10/Library/Frameworks/Python.framework/Versions/3.10/bin/python3.10</code></pre><br><h2 id="四、单个脚本使用"><a href="#四、单个脚本使用" class="headerlink" title="四、单个脚本使用"></a><strong>四、单个脚本使用</strong></h2><blockquote><p>  参考：</p><ul><li><a href="https://github.com/astral-sh/uv?tab=readme-ov-file#scripts" target="_blank" rel="noopener">https://github.com/astral-sh/uv?tab=readme-ov-file#scripts</a></li></ul></blockquote><p>uv 可以管理单文件脚本的依赖项和环境；</p><p>例如：创建一个新脚本并添加内联元数据来声明其依赖项：</p><pre><code class="bash">$ echo &#39;import requests; print(requests.get(&quot;https://astral.sh&quot;))&#39; &gt; example.py$ uv add --script example.py requestsUpdated `example.py`</code></pre><p>然后，在隔离的虚拟环境中运行脚本：</p><pre><code class="bash">$ uv run example.pyReading inline script metadata from: example.pyInstalled 5 packages in 12ms&lt;Response [200]&gt;</code></pre><br><h2 id="五、项目中使用"><a href="#五、项目中使用" class="headerlink" title="五、项目中使用"></a><strong>五、项目中使用</strong></h2><h3 id="1、选用python版本"><a href="#1、选用python版本" class="headerlink" title="1、选用python版本"></a><strong>1、选用python版本</strong></h3><p>在具体的某个项目中，进入项目目录，使用如下命令指定选用的python版本：</p><pre><code class="bash">uv python pin 版本号</code></pre><p>这个命令会在指定目录下创建一个<code>.python-version</code>文件，内容如下：</p><pre><code class="bash">❯ uv python pin 3.10                                    Pinned `.python-version` to `3.10`❯ cat .python-version  3.10</code></pre><blockquote><p>   <strong>注意：这里选用的python版本只和uv管理的虚拟环境有关系，和我们全局的python、python3命令都没有关系！</strong></p></blockquote><br><h3 id="2、创建虚拟环境"><a href="#2、创建虚拟环境" class="headerlink" title="2、创建虚拟环境"></a>2、创建虚拟环境</h3><p>创建项目有两种方式，第一种方式，先创建好项目目录，然后设置python版本并初始化uv虚拟环境：</p><pre><code class="sh">uv python pin 3.10uv init # 初始化</code></pre><p>执行了uv init之后，会在当前目录下创建几个文件，同时也会在当前目录下执行git init创建出一个新的git仓库来：</p><pre><code class="sh">❯ uv python pin 3.13Pinned `.python-version` to `3.13`❯ uv initInitialized project `test-code`❯ lsREADME.md      main.py        pyproject.toml</code></pre><p>另外一个方式是在init之后添加一个项目名，会自动创建项目文件夹</p><pre><code class="sh">uv init 项目名</code></pre><blockquote><p>  <strong>如果需要指定特定python版本，建议使用第一种方式来创建项目；</strong></p><p>  <strong>否则还需要手动修改pyproject.toml配置文件里面需要的python版本。</strong></p></blockquote><br><h3 id="3、添加依赖"><a href="#3、添加依赖" class="headerlink" title="3、添加依赖"></a><strong>3、添加依赖</strong></h3><pre><code class="sh">uv add 依赖项</code></pre><p>比如添加requests库：</p><pre><code>uv add requests</code></pre><p>还可以指定具体版本：</p><pre><code>uv add requests==版本号</code></pre><p>执行了这个命令后，会在当前目录下创建<code>.venv</code>虚拟环境目录（在vscode里面可以选择这个目录作为虚拟环境，否则代码解析会有问题）；</p><p>并添加我们要的依赖项，同时会新增一个uv.lock文件，用于存放依赖项版本相关的信息。</p><p>pyproject.toml文件中的dependencies字段也会包含需要的依赖项：</p><pre><code class="sh">❯ uv add requestsUsing CPython 3.13.1 interpreter at: /opt/homebrew/opt/python@3.13/bin/python3.13Creating virtual environment at: .venvResolved 6 packages in 13.85sPrepared 5 packages in 5.55sInstalled 5 packages in 13ms + certifi==2025.1.31 + charset-normalizer==3.4.1 + idna==3.10 + requests==2.32.3 + urllib3==2.4.0</code></pre><p>而且，从这个输出中也能看到，它自动使用了<code>.python-version</code>指定的3.13版本的python；</p><p>和当前全局配置下的python3指向什么版本没有关系（全局python3指向的是3.10版本）；</p><br><h3 id="4、运行程序"><a href="#4、运行程序" class="headerlink" title="4、运行程序"></a>4、运行程序</h3><p>依赖添加好后，就可以使用uv来运行python程序了</p><pre><code class="sh">uv run 程序文件名 [命令行参数]</code></pre><p>uv会自动按照我们的配置来运行程序，无序我们手动维护依赖项，也不需要手动去source各式各样的虚拟环境！</p><br><h3 id="5、其他机器中配置环境"><a href="#5、其他机器中配置环境" class="headerlink" title="5、其他机器中配置环境"></a><strong>5、其他机器中配置环境</strong></h3><p>在其他机器拉取代码后，也需要配置虚拟环境、下载项目依赖；</p><p>如果使用 uv 进行管理只需要一步：</p><pre><code class="bash">uv sync</code></pre><p>即可同步环境，随后使用：</p><pre><code class="bash">uv run 程序文件名 [命令行参数]</code></pre><p>即可运行！</p><br><h2 id="六、uvx命令"><a href="#六、uvx命令" class="headerlink" title="六、uvx命令"></a><strong>六、uvx命令</strong></h2><p>随着uv下载的还有一个uvx命令，和 <code>pipx</code> 类似；</p><p>使用 uvx 命令可以执行或安装一些使用 Python 编写的命令行工具；</p><blockquote><p>  参考：</p><ul><li><a href="https://github.com/astral-sh/uv?tab=readme-ov-file#tools" target="_blank" rel="noopener">https://github.com/astral-sh/uv?tab=readme-ov-file#tools</a></li></ul></blockquote><h3 id="1、临时使用命令"><a href="#1、临时使用命令" class="headerlink" title="1、临时使用命令"></a><strong>1、临时使用命令</strong></h3><p>例如，在一个临时环境中执行一个工具：</p><pre><code class="bash">➜  blog git:(save) ✗ uvx pycowsay &#39;hello world!&#39;Installed 1 package in 6ms/Users/zk/.cache/uv/archive-v0/C-520Z4yR2_MYfgN_xvWl/lib/python3.12/site-packages/pycowsay/main.py:23: SyntaxWarning: invalid escape sequence &#39;\ &#39;  &quot;&quot;&quot;  ------------&lt; hello world! &gt;  ------------   \   ^__^    \  (oo)\_______       (__)\       )\/\           ||----w |           ||     ||</code></pre><p>可以看到，工具会被临时下载到 <code>~/.cache/uv</code> 中！</p><br><h3 id="2、全局安装工具"><a href="#2、全局安装工具" class="headerlink" title="2、全局安装工具"></a><strong>2、全局安装工具</strong></h3><p>也可以全局安装一个工具：</p><pre><code class="bash">$ uv tool install ruffResolved 1 package in 6msInstalled 1 package in 2ms + ruff==0.5.0Installed 1 executable: ruff$ ruff --versionruff 0.5.0</code></pre><blockquote><p>  参考：</p><ul><li><a href="https://docs.astral.sh/uv/guides/tools/" target="_blank" rel="noopener">tools documentation</a></li></ul></blockquote><br><p>uvx命令本质上是uv tool run命令的别名：</p><pre><code class="bash">uvx python main.py# 等价于uv run main.py# 等价于uv tool run main.py</code></pre><p>实际例子，如下这两个命令是等价的：</p><pre><code class="bash">❯ uvx --directory ~/data/code/python/test_code python main.pyHello from test-code!❯ uv tool run --directory ~/data/code/python/test_code python main.pyHello from test-code!</code></pre><br><h2 id="七、配置"><a href="#七、配置" class="headerlink" title="七、配置"></a><strong>七、配置</strong></h2><h3 id="1、依赖镜像源配置"><a href="#1、依赖镜像源配置" class="headerlink" title="1、依赖镜像源配置"></a><strong>1、依赖镜像源配置</strong></h3><blockquote><p>  参考：</p><ul><li><a href="https://blog.csdn.net/qq_41472205/article/details/145686414" target="_blank" rel="noopener">https://blog.csdn.net/qq_41472205/article/details/145686414</a></li></ul></blockquote><h4 id="（1）项目级"><a href="#（1）项目级" class="headerlink" title="（1）项目级"></a><strong>（1）项目级</strong></h4><p>uv下载第三方库本质上也是通过pypi源下载的，所以在国内网络环境中默认链接速度会很慢，可以在项目目录的pyproject.toml中添加如下内容来使用清华源：</p><pre><code class="toml">[[tool.uv.index]]url = &quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;default = true</code></pre><h4 id="（2）命令行级"><a href="#（2）命令行级" class="headerlink" title="（2）命令行级"></a><strong>（2）命令行级</strong></h4><p>运行uv add命令的时候也可以指定镜像源</p><pre><code class="bash">uv add --default-index https://pypi.tuna.tsinghua.edu.cn/simple requests</code></pre><h4 id="（3）全局"><a href="#（3）全局" class="headerlink" title="（3）全局"></a><strong>（3）全局</strong></h4><p>uv也提供了全局的配置项，可以通过环境变量<code>UV_DEFAULT_INDEX</code>配置镜像源</p><pre><code class="bash">export UV_DEFAULT_INDEX=https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><blockquote><p>  <strong>注意：全局的配置项优先级低于pyproject.toml中配置的镜像源；</strong></p></blockquote><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p><strong>官方仓库:</strong></p><ul><li><a href="https://github.com/astral-sh/uv" target="_blank" rel="noopener">https://github.com/astral-sh/uv</a></li></ul><p><strong>官方文档:</strong></p><ul><li><a href="https://docs.astral.sh/uv/" target="_blank" rel="noopener">https://docs.astral.sh/uv/</a></li></ul><p><strong>参考文章:</strong></p><ul><li><a href="https://blog.csdn.net/muxuen/article/details/147544307" target="_blank" rel="noopener">https://blog.csdn.net/muxuen/article/details/147544307</a></li></ul><br>]]></content>
    
    
    <summary type="html">uv是一个Python项目管理工具，类似于pip、venv、virtualenv和pip-tools的组合体，但它非常快。本文总结了如何安装和使用uv。</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="Python" scheme="https://jasonkayzk.github.io/tags/Python/"/>
    
    <category term="uv" scheme="https://jasonkayzk.github.io/tags/uv/"/>
    
  </entry>
  
  <entry>
    <title>gemini-cli使用</title>
    <link href="https://jasonkayzk.github.io/2025/07/14/gemini-cli%E4%BD%BF%E7%94%A8/"/>
    <id>https://jasonkayzk.github.io/2025/07/14/gemini-cli%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-14T05:17:01.000Z</published>
    <updated>2025-07-30T10:34:36.203Z</updated>
    
    <content type="html"><![CDATA[<p>有一段时间没有写博客了，这两年AI的发展日新月异，真是可怕。最近终于把学校的一摊子事忙完了，接下来还有个创新大赛、八月份又要去广州参加国培，不可谓不忙；</p><p>本文介绍了如何使用 Google 最新出的 gemini-cli：</p><ul><li><a href="https://github.com/google-gemini/gemini-cli" target="_blank" rel="noopener">https://github.com/google-gemini/gemini-cli</a></li></ul><br><a id="more"></a><h1 id="gemini-cli使用"><a href="#gemini-cli使用" class="headerlink" title="gemini-cli使用"></a><strong>gemini-cli使用</strong></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>目前大家可能用的都是 Cursor 或者 VSCode 里的插件（如 Cline）、阿里的通义灵码，以及腾讯的 CodeBuddy 这类界面化的 AI 编码交互方式。</p><p>而 <a href="https://github.com/google-gemini/gemini-cli" target="_blank" rel="noopener">gemini-cli</a> 是一个让你可以在命令行使用和上面功能类似的命令行工具！</p><p>功能特点：</p><ul><li><strong>AI 编程伙伴：</strong> 你可以直接在终端里问它编程问题、让它帮你写代码、解释错误信息或者优化现有代码。</li><li><strong>多功能助手：</strong> 不仅仅是代码，你还可以向它提问各种问题，甚至可以发图片（比如错误截图）给它看，让它帮你分析。</li><li><strong>简化工作：</strong> 对于开发者和技术人员来说，这意味着不用离开熟悉的终端界面，就能快速获得 AI 的帮助，从而提高工作效率。</li><li><strong>开源免费：</strong> 它是开源的，并且在预览期间为个人开发者提供了非常慷慨的免费使用额度。</li></ul><br><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a><strong>二、安装</strong></h2><p>直接使用 npm 全局安装即可：</p><pre><code class="bash">npm install -g @google/gemini-cli</code></pre><br><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a><strong>三、使用</strong></h2><p>直接在命令行输入：</p><pre><code class="bash">gemini</code></pre><p>即可打开：</p><pre><code>➜  blog git:(save) ✗ gemini ███            █████████  ██████████ ██████   ██████ █████ ██████   █████ █████░░░███         ███░░░░░███░░███░░░░░█░░██████ ██████ ░░███ ░░██████ ░░███ ░░███  ░░░███      ███     ░░░  ░███  █ ░  ░███░█████░███  ░███  ░███░███ ░███  ░███    ░░░███   ░███          ░██████    ░███░░███ ░███  ░███  ░███░░███░███  ░███     ███░    ░███    █████ ░███░░█    ░███ ░░░  ░███  ░███  ░███ ░░██████  ░███   ███░      ░░███  ░░███  ░███ ░   █ ░███      ░███  ░███  ░███  ░░█████  ░███ ███░         ░░█████████  ██████████ █████     █████ █████ █████  ░░█████ █████░░░            ░░░░░░░░░  ░░░░░░░░░░ ░░░░░     ░░░░░ ░░░░░ ░░░░░    ░░░░░ ░░░░░Tips for getting started:1. Ask questions, edit files, or run commands.2. Be specific for the best results.3. Create GEMINI.md files to customize your interactions with Gemini.4. /help for more information.╭─────────────────────────────────────────────────────────────────────────────────────────────╮│ &gt;   Type your message or @path/to/file                                                      │╰─────────────────────────────────────────────────────────────────────────────────────────────╯~/workspace/blog (save*)       no sandbox (see /docs)        gemini-2.5-pro (100% context left)</code></pre><p>首次运行时，它会引导完成几个设置步骤：</p><ul><li><strong>选择主题风格：</strong> 为界面选择一个喜欢的颜色主题。</li><li><strong>授权登录：</strong> 它会提示您通过 Google 账户进行登录授权。这通常会生成一个链接，需要在浏览器中打开并授权。</li></ul><blockquote><p>  <strong>授权后，就可以享受免费的调用额度（预览版期间每天有 1000 次请求）。</strong></p></blockquote><br><h2 id="四、配置API登陆"><a href="#四、配置API登陆" class="headerlink" title="四、配置API登陆"></a><strong>四、配置API登陆</strong></h2><p>如果你没有配置 API，每次运行 gemini-cli 都要重新登陆一次，可以配置 API 修改登录方式；</p><h3 id="1、访问-Google-AI-Studio"><a href="#1、访问-Google-AI-Studio" class="headerlink" title="1、访问 Google AI Studio"></a><strong>1、访问 Google AI Studio</strong></h3><p>在浏览器中打开网址：</p><ul><li><strong><a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener">https://aistudio.google.com/app/apikey</a></strong></li></ul><h3 id="2、创建或获取密钥"><a href="#2、创建或获取密钥" class="headerlink" title="2、创建或获取密钥"></a><strong>2、创建或获取密钥</strong></h3><ul><li>如果尚未登录，请使用您的 Google 账户登录。</li><li>点击 <strong>“Create API key”</strong> (创建 API 密钥) 按钮。</li><li>系统会生成一个新的 API 密钥。这是一个很长的字符串。</li></ul><h3 id="3、复制并妥善保管"><a href="#3、复制并妥善保管" class="headerlink" title="3、复制并妥善保管"></a><strong>3、复制并妥善保管</strong></h3><ul><li>立即点击密钥旁边的复制，复制 key；</li></ul><h3 id="4、引入环境变量"><a href="#4、引入环境变量" class="headerlink" title="4、引入环境变量"></a><strong>4、引入环境变量</strong></h3><p>配置：</p><pre><code class="bash">export GEMINI_API_KEY=&quot;YOUR_API_KEY&quot;</code></pre><p>将你复制的内容替换 <code>YOUR_API_KEY</code>；</p><blockquote><p>  有关 Google Gemini API 的使用也可以看这篇文章：</p><ul><li><a href="http://apifox.com/apiskills/how-to-use-gemini-api/" target="_blank" rel="noopener">Google Gemini API 接口调用教程，图文讲解</a></li></ul></blockquote><h3 id="5、生效"><a href="#5、生效" class="headerlink" title="5、生效"></a><strong>5、生效</strong></h3><p>运行 <code>source ~/.zshrc</code> 或重启终端；</p><p>随后在登录选项中选择 API Key 的方式即可！</p><br><h2 id="五、其他说明"><a href="#五、其他说明" class="headerlink" title="五、其他说明"></a><strong>五、其他说明</strong></h2><p>启动 gemini 后，引用本地文件 可以使用 <code>@</code> 来选择文件；</p><p>更多内容可以通过 <code>/help</code> 获取：</p><pre><code class="bash">Basics:                                                                                     ││ Add context: Use @ to specify files for context (e.g., @src/myFile.ts) to target specific   ││ files or folders.                                                                           ││ Shell mode: Execute shell commands via ! (e.g., !npm run start) or use natural language     ││ (e.g. start server).                                                                        ││                                                                                             ││ Commands:                                                                                   ││  /clear - clear the screen and conversation history                                         ││  /help - for help on gemini-cli                                                             ││  /memory - Commands for interacting with memory.                                            ││    show - Show the current memory contents.                                                 ││    add - Add content to the memory.                                                         ││    refresh - Refresh the memory from the source.                                            ││  /theme - change the theme                                                                  ││  /docs - open full Gemini CLI documentation in your browser                                 ││  /auth - change the auth method                                                             ││  /editor - set external editor preference                                                   ││  /privacy - display the privacy notice                                                      ││  /stats - check session stats. Usage: /stats [model|tools]                                  ││  /mcp - list configured MCP servers and tools                                               ││  /extensions - list active extensions                                                       ││  /tools - list available Gemini CLI tools                                                   ││  /about - show version info                                                                 ││  /bug - submit a bug report                                                                 ││  /chat - Manage conversation history. Usage: /chat &lt;list|save|resume&gt; &lt;tag&gt;                 ││  /quit - exit the cli                                                                       ││  /compress - Compresses the context by replacing it with a summary.                         ││  ! - shell command                                                                          ││                                                                                             ││ Keyboard Shortcuts:                                                                         ││ Enter - Send message                                                                        ││ Ctrl+J - New line                                                                           ││ Up/Down - Cycle through your prompt history                                                 ││ Alt+Left/Right - Jump through words in the input                                            ││ Shift+Tab - Toggle auto-accepting edits                                                     ││ Ctrl+Y - Toggle YOLO mode                                                                   ││ Esc - Cancel operation                                                                      ││ Ctrl+C - Quit application</code></pre><p>官方也提供了大量的经典案例：</p><ul><li><a href="https://github.com/google-gemini/gemini-cli?tab=readme-ov-file#popular-tasks" target="_blank" rel="noopener">https://github.com/google-gemini/gemini-cli?tab=readme-ov-file#popular-tasks</a></li></ul><br><h2 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a><strong>六、后记</strong></h2><p>实际上和<a href="https://wiki.eryajf.net/" target="_blank" rel="noopener">这位博主</a>一样，我最开始也不喜欢使用命令行：</p><blockquote><p>  由于先入为主的一些体验，我一直习惯于使用像 Cursor 或者 VSCode 里的插件（如 Cline）、阿里的通义灵码，以及腾讯的 CodeBuddy 这类界面化的 AI 编码交互方式。相比之下，对于 Claude cli、Gemini cli 这类基于终端、命令行的交互方式，我一直提不起兴趣。</p><p>  直到最近，我体验了几次 Claude cli 的编码功能，这才让我对以往的成见有了一些改变。过去我之所以更习惯插件式的交互方式，是因为它们的操作更为直观。无论是选择代码段、文件，还是插入图片，都非常直接简单。因此，我一直认为这种交互方式就是最优雅的 AI 编码方式。</p><p>  正因为这种先入为主的心态，我始终对 Cli 这类交互方式有些抵触。我一直不太能理解，在编辑器里写代码，却要用终端来进行 AI 编码，这到底是一种怎样的交互逻辑？总觉得这种方式很割裂，与 AI 的交互以及 AI 的编码过程变成了一种黑盒，很不直观。这也是我迟迟没有尝试这种编码方式的原因。</p></blockquote><p>但是在安装并且体验了之后，发现确实要方便很多！</p><p>他最后的总结也是我的体验以及一些个人感想：</p><blockquote><p>  <font color="#f00"><strong>这让我意识到，很多时候限制我们接受新事物的，并不是事物本身的缺点。那些所谓的缺点，或许只是我们自己想象出来的。真正阻碍我们发展的，往往是自己内心深处那些根深蒂固的成见。我们习惯于依赖以往成功的经验，固守在自己的舒适区，对不熟悉的方式和交互逻辑产生抵触情绪。而正是这种抵触，让我们与更美好的事物始终形同陌路。</strong></font></p><p>  <font color="#f00"><strong>这次 Claude cli 的体验给了我一个提醒：应该始终保持开放的心态，勇于尝试那些看似不符合直觉的新方法或新工具。也许这样能够带来许多意想不到的效率提升和全新的体验，要善于打破自己的成见，才能真正拥抱进步。</strong></font></p></blockquote><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>参考：</p><ul><li><a href="https://www.v2ex.com/t/1144487" target="_blank" rel="noopener">https://www.v2ex.com/t/1144487</a></li><li><a href="https://wiki.eryajf.net/pages/d89910/" target="_blank" rel="noopener">https://wiki.eryajf.net/pages/d89910/</a></li></ul><br>]]></content>
    
    
    <summary type="html">有一段时间没有写博客了，这两年AI的发展日新月异，真是可怕。最近终于把学校的一摊子事忙完了，接下来还有个创新大赛、八月份又要去广州参加国培，不可谓不忙。本文介绍了如何使用 Google 最新出的 gemini-cli。</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="AI" scheme="https://jasonkayzk.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>跑步一年多的一些总结和感想</title>
    <link href="https://jasonkayzk.github.io/2025/05/04/%E8%B7%91%E6%AD%A5%E4%B8%80%E5%B9%B4%E5%A4%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E6%83%B3/"/>
    <id>https://jasonkayzk.github.io/2025/05/04/%E8%B7%91%E6%AD%A5%E4%B8%80%E5%B9%B4%E5%A4%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E6%83%B3/</id>
    <published>2025-05-04T13:12:38.000Z</published>
    <updated>2025-07-30T10:34:36.228Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉跑步已经锻炼了有一年时间了，从最开始200米都跑不下来，到现在跑完半马，变化还是巨大的。</p><p>本文记录一些跑步的感想。</p><br><a id="more"></a><html lang="en">    <div style="text-align: center;">   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="320" height="65" src="https://i.y.qq.com/n2/m/outchain/player/index.html?songid=1911822&songtype=0"></iframe></div></html><h1 id="跑步一年多的一些总结和感想"><a href="#跑步一年多的一些总结和感想" class="headerlink" title="跑步一年多的一些总结和感想"></a><strong>跑步一年多的一些总结和感想</strong></h1><h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a><strong>新的开始</strong></h2><h3 id="契机"><a href="#契机" class="headerlink" title="契机"></a><strong>契机</strong></h3><p>最开始让我跑步的原因是当时刚刚告别程序员这个行业，体检的时候发现自己居然接近三高了：</p><ul><li>血压偏高</li><li>血脂偏高</li><li>尿酸偏高</li></ul><p>并且体重接近 90kg！</p><blockquote><p>  <strong>要知道上大学的时候，我还是易瘦体质，体重还没超过70kg！</strong></p></blockquote><p>正巧当时还没有确定好工作，空余时间比较多，加上膝盖已经出现了问题，所以就打算锻炼身体。</p><blockquote><p>  <strong>其实在此之前，在深圳、福州就已经开始断断续续的跑步了！</strong></p><p>  <strong>但是没有真正的把跑步当作一件事情认真对待，只是简单的跑一跑。</strong></p></blockquote><p>真正认真对待这件事还是回家之后，想跑一跑步，突然发现自己身体素质差的要命！</p><p>当时刚从南方回家，大概在十一月份，因为北方已经开始降温了，天气比较冷：</p><p>基本上遇到冷空气就要打喷嚏，并且几乎每个月都要感冒，身体差的不行；</p><p>再加上医院的体检结果也是非常吓人，很多指标都偏高！</p><p>但是实际上压死骆驼的最后一根稻草是：</p><p>我去运动场上试跑了一下，发现自己<strong>连200米都坚持不下来！</strong></p><blockquote><p>  <strong>这个对我来说印象十分深刻：</strong></p><p>  <strong>我至今都还能记得，自己跑了200米就开始大口大口喘气的感觉！</strong></p></blockquote><br><hr><br><h3 id="跑步训练-v0-1"><a href="#跑步训练-v0-1" class="headerlink" title="跑步训练-v0.1"></a><strong>跑步训练-v0.1</strong></h3><p>由于没有经验，最开始在跑步的时候是没有什么规划的，也不知道训练方法之类的；</p><p>基本上就是来到体育场，也没有热身，能跑多快跑多快；</p><p>这是最早的一张图（当时用的APP还是小米运动）：</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-1.png" alt="image-20250505091951310" style="zoom: 25%;"><p>基本上跑个400米就不行了。</p><p>而且因为没有热身，基本上跑完之后，第二天大腿、小腿还会疼；</p><br><hr><br><h3 id="跑步训练-v1-0"><a href="#跑步训练-v1-0" class="headerlink" title="跑步训练-v1.0"></a><strong>跑步训练-v1.0</strong></h3><p>实际上即使没有任何训练计划，跑了几天之后发现自己体力也是有明显进步的；</p><blockquote><p>  可能是因为原本的身体基础实在是太差、段位太低，所以提升的比较快！</p></blockquote><p>虽说是明显的进步，实际上也就是能坚持跑个1公里左右；</p><p>于是在这个时候开始准备一些更长的训练：</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-2.png" alt="image-20250505091958741" style="zoom:25%;"><p>这个阶段我的跑步策略是：</p><ul><li>先走一圈热身</li><li>然后再跑一公里</li><li>然后再走一圈</li><li>然后再跑一公里</li></ul><p>因为一开始根本是无法坚持跑完3公里的路程的，所以基本上只能分成3组，每组大概是1公里的样子；</p><p>中间穿插一小段热身缓和；</p><blockquote><p>  这个阶段大概持续了半年左右：</p><ul><li><strong>2023年11月-12月</strong></li><li><strong>2024年2月-7月</strong></li></ul></blockquote><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-3.png" alt="image-20250505092027429" style="zoom:25%;"><br><hr><br><h3 id="跑步训练-v2-0"><a href="#跑步训练-v2-0" class="headerlink" title="跑步训练-v2.0"></a><strong>跑步训练-v2.0</strong></h3><p>上面的分阶段跑步大概持续了大半年左右，一直到了2024年的8月份；</p><p>这个时候训练从原来的3组1公里，慢慢变成了：3组1.5公里、4组1.5公里、一组5公里等等；</p><p>所以在这个阶段，慢慢开始考虑，是不是可以不再分组了，而是一口气跑下来5公里或者更长呢？</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-4.png" alt="image-20250505092428629" style="zoom:25%;"><p>于是从8月份开始，开始尝试5公里的跑步；</p><p>最开始的训练是非常痛苦的，因为5公里的长度对于我来说已经是非常长了，所以基本上是跑跑停停：</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-5.png" alt="image-20250505092640311" style="zoom:25%;"><br><p>也是从这一阶段开始，我的跑步APP也从小米运动转到了 Keep；</p><p>同时也开始真正记录一些跑步数据、并且真正开始看和跑步相关的知识；</p><p>也许是之前训练了很长的时间，所以在这一阶段，5公里已经开始能跑出比较不错的成绩了！</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-6.png" alt="image-20250505093052979" style="zoom:25%;"><br><p>当时也是迷上了一部动漫：</p><ul><li><a href="https://movie.douban.com/subject/30238385/" target="_blank" rel="noopener">《風が強く吹いている》</a></li></ul><blockquote><p>  <strong>实际上这本书在我本科上学期间就已经读过了，非常推荐！</strong></p></blockquote><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-7.png" alt="image-20250505093337486" style="zoom:25%;"><p>同时，也是在知乎上看到了这么一幅图：</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-8.png" alt="image-20250505093407429" style="zoom:25%;"><p>所以开始追求跑步的配速！</p><br><p>同时也在 Github 搭建了：</p><ul><li><a href="https://jasonkayzk.github.io/running/">running-page</a></li></ul><blockquote><p>  <strong>感谢 <a href="https://github.com/yihong0618" target="_blank" rel="noopener">yihong0618</a>！❤️</strong></p></blockquote><p>进一步激发了我的跑步热情！</p><br><hr><br><h3 id="跑步训练-v3-0"><a href="#跑步训练-v3-0" class="headerlink" title="跑步训练-v3.0"></a><strong>跑步训练-v3.0</strong></h3><p>经历了5公里洗礼之后，再继续跑步的时候，就想慢慢探索自己能否跑更长的距离；</p><p>也是这一时期，感觉自己可以开始试着准备准备半程马拉松了！</p><p>于是开始挑战10km这个距离；</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-9.png" alt="image-20250505093926549" style="zoom:25%;"><blockquote><p>  <strong>上面的这次跑步实际上只是为了看看自己1个小时究竟能跑多远！</strong></p></blockquote><p>说是挑战10公里，<strong>实际上要比我的第一个5公里要简单很多了！</strong></p><p>但是长距离带来了另外的问题，就是：</p><ul><li><strong>自己的脚底开始磨出水泡！</strong></li></ul><p>然后也开始慢慢意识到：</p><p><font color="#f00"><strong>即使跑步速度不快的情况下，时间或者距离足够长，实际上会将你的鞋底摩擦、衣服摩擦造成的影响给无限放大，导致出现短跑不会遇到的问题！</strong></font></p><p>也是这一阶段开始，自己开始注意在运动前保护自己：</p><ul><li><strong>跑前拉伸、热身1-2公里</strong></li><li><strong>注意检查自己的鞋是否存在磨脚等情况</strong></li><li><strong>跑步的状态等</strong></li></ul><br><hr><br><h3 id="跑步训练-v4-0"><a href="#跑步训练-v4-0" class="headerlink" title="跑步训练-v4.0"></a><strong>跑步训练-v4.0</strong></h3><p>4.0 版本实际上也就是目前的训练版本；</p><p>在今年的2月份，买了 Garmin 255 的手表，专门用来记录跑步！</p><p>同时，在跑步训练上也更加专注长距离的跑步，基本上每次训练都是10公里的量！</p><p>同时也是完成了半马挑战！</p><blockquote><p>  虽然成绩不是很好，哈哈。</p></blockquote><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-10.png" alt="image-20250505094746369" style="zoom:25%;"><p>也是这几天，买了更加专业的跑鞋（李宁飞电6C）；</p><blockquote><p>  <font color="#f00"><strong>跑步装备越来越专业，实际上只是为了激励自己能更好的坚持跑下去！</strong></font></p><p>  <font color="#f00"><strong>不过我个人觉得，实际上更重要的是要能坚持迈开腿跑下去！装备并没有那么重要！</strong></font></p></blockquote><p>当然，后面也会挑战更多的半马；</p><p>上面年由于工作比较忙，所以也是希望下半年有机会参加郑开的半马！</p><br><hr><br><h2 id="一些收获和感想"><a href="#一些收获和感想" class="headerlink" title="一些收获和感想"></a><strong>一些收获和感想</strong></h2><h3 id="1、身体健康"><a href="#1、身体健康" class="headerlink" title="1、身体健康"></a><strong>1、身体健康</strong></h3><p>最大的收获当然是：<strong>自己的身体健康！</strong></p><p>坚持跑步以来，到目前为止，自己体检时的各项身体指标已经全部正常，并且处于中间位置；</p><p>高血压、高血脂、高尿酸全部不见了；</p><p>体重也从90公斤减到了70公斤！</p><p>目前为止，生病感冒等现象也没发生过了！</p><br><h3 id="2、精神状态"><a href="#2、精神状态" class="headerlink" title="2、精神状态"></a><strong>2、精神状态</strong></h3><p>整个人的精神面貌也好了不少；</p><p>锻炼给人的感觉应该是要消耗大量的体力、导致身体疲惫。</p><p><font color="#f00"><strong>但是实际上，锻炼之后只是当时比较累，事后反而会让你精力充沛，这是比较反直觉的！</strong></font></p><br><h3 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a><strong>3、其他</strong></h3><p>除了以上这些之外，实际上自己对于距离、速度的掌控也变得精确。</p><p>同时<strong>对于长跑也不再那么恐惧</strong>，目前已经参加了：</p><ul><li>学校10公里微马拉松；</li><li>集团2次马拉松：团体赛、个人赛；</li></ul><p>同时觉得也更能掌控自己的身体！</p><br><h2 id="跑步时我在做什么"><a href="#跑步时我在做什么" class="headerlink" title="跑步时我在做什么"></a><strong>跑步时我在做什么</strong></h2><p>实际上这来自于知乎的一个问题：</p><ul><li><a href="https://www.zhihu.com/question/25947722" target="_blank" rel="noopener">《你跑步的时候在想什么？》</a></li></ul><p>那要问跑步时我在做什么，实际上答案当然是：跑步！</p><p>这里说的是除了跑步之外，我在做什么，包括：</p><ul><li>大脑在想什么；</li><li>耳朵在听什么；</li><li>眼睛在看什么；</li><li>……</li></ul><br><h3 id="大脑在想什么"><a href="#大脑在想什么" class="headerlink" title="大脑在想什么"></a><strong>大脑在想什么</strong></h3><p>实际上脑子里在想的，和知乎上有些人写的差不多；</p><p>更多的是在思考：</p><ul><li>好痛苦啊？！</li><li>现在跑了多久了？</li><li>怎么还有5公里？！</li><li>速度怎么这么慢？</li><li>……</li></ul><blockquote><p>  <strong>我在跑步的时候是思考不了其他事情的，我也很佩服那些大脑是多核处理器的人；</strong></p><p>  <strong>能在跑步的同时思考一些其他时间，我是不行；</strong></p></blockquote><p><font color="#f00"><strong>这个过程对于我来说有点类似于冥想，只不过我是在匀速运动中冥想，而有的人是静止状态。</strong></font></p><br><h3 id="耳朵在听什么"><a href="#耳朵在听什么" class="headerlink" title="耳朵在听什么"></a><strong>耳朵在听什么</strong></h3><p>大部分情况下都是在听自己的一些歌单；</p><blockquote><p>  <strong>关于这个歌单，后文会给大家介绍；</strong></p></blockquote><p>当然还有一些跑步的大牛会听一些播客；</p><p>不过和上面的原因一样，我感觉我听这些根本进不去脑子；</p><p>而且如果我听播客，我跑步的时候可能会很别扭。</p><p>所以我一般就是听歌曲；</p><br><h3 id="眼睛在看什么"><a href="#眼睛在看什么" class="headerlink" title="眼睛在看什么"></a><strong>眼睛在看什么</strong></h3><p>我基本上都是在运动场跑步，所以一般情况下都不会是我自己；</p><p>在跑步的时候，可以观察一下其他也在跑步的朋友，他的：</p><ul><li>跑步姿势；</li><li>跑步速度；</li><li>跑了多久；</li><li>……</li></ul><p>然后感叹：我靠他怎么这么厉害、我跟不上他了；</p><blockquote><p>  <strong>不过相信我，如果你能在运动场跑个一个小时以上的时间，基本上至少能熬走2-3波来锻炼的人！</strong></p></blockquote><br><h2 id="一些相关的推荐"><a href="#一些相关的推荐" class="headerlink" title="一些相关的推荐"></a><strong>一些相关的推荐</strong></h2><p>这里给大家分享一些我目前用到的一些工具等等；</p><br><h3 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a><strong>歌单</strong></h3><p>我平时听的歌曲是一些节奏比较强烈的歌，尤其是鼓点最好能配上你的步频节奏那就更好了！</p><p>除此之外，我个人常听的一些歌是：</p><ul><li><font color="#f00"><strong>原神战斗bgm</strong></font></li></ul><p>例如：</p>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="320" height="65" src="https://i.y.qq.com/n2/m/outchain/player/index.html?songid=414726056&songtype=0"></iframe><p><font color="#f00"><strong>虽然我已经好久都没玩原神了，但是听这些歌曲给我一种我自己正在游戏世界里奔跑游荡的感觉！</strong></font></p><br><p>除此之外，你可以试试一些播客～</p><br><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a><strong>APP</strong></h3><h4 id="一、跑步记录"><a href="#一、跑步记录" class="headerlink" title="一、跑步记录"></a><strong>一、跑步记录</strong></h4><p>跑步记录的 APP 我这里推荐几个；</p><h5 id="1、Keep"><a href="#1、Keep" class="headerlink" title="1、Keep"></a><strong>1、Keep</strong></h5><p>可以在 Keep 里面设置自定义的训练内容，比如 5公里、10公里、15公里等；</p><p>然后在每一公里处都设置播报，当然你的速度快了或者慢了，Keep 也都有提示；</p><p>总体来说还是比较方便的；</p><br><h5 id="2、Garmin-Connect"><a href="#2、Garmin-Connect" class="headerlink" title="2、Garmin Connect"></a><strong>2、Garmin Connect</strong></h5><p>由于我目前用的是佳明的手表，所以一般情况下都是使用手表记录跑步，然后通过 Connect 同步到云端；</p><p>当然，如果你有其他的手表，比如：Coros、Apple Watch、华为、小米 等等，也是可以的！</p><br><h4 id="二、听歌"><a href="#二、听歌" class="headerlink" title="二、听歌"></a><strong>二、听歌</strong></h4><p>我一般使用的是 QQ 音乐，因为充了会员，歌曲还是比较多的；</p><p>除此之外，也推荐大家使用汽水音乐，他是字节推出的一个听歌APP；</p><p>使用汽水音乐有一个好处就是：</p><ul><li><strong>他的交互模式类似于抖音，上划就能下一曲了，比其他APP切歌方便的多！</strong></li><li><strong>同时，他的歌曲推荐也还可以！</strong></li></ul><p>如果你的手表包含了歌曲功能，也是可以的！</p><br><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a><strong>网站</strong></h3><h4 id="一、RunningPage（强烈推荐）"><a href="#一、RunningPage（强烈推荐）" class="headerlink" title="一、RunningPage（强烈推荐）"></a><strong>一、RunningPage（强烈推荐）</strong></h4><p>这个是一个可以自行部署并生成你的跑步记录的网站：</p><ul><li><a href="https://github.com/yihong0618/running_page" target="_blank" rel="noopener">https://github.com/yihong0618/running_page</a></li></ul><p>支持许多的手表设备和平台；</p><blockquote><p>  <strong>包括 Keep！</strong></p></blockquote><p>下面的这个网站就是我搭建的：</p><ul><li><a href="https://jasonkayzk.github.io/running_page/">https://jasonkayzk.github.io/running_page/</a></li></ul><p><strong>搭建完成后，每天会自动获取你的运动数据，并且更新内容，非常的酷！</strong></p><br><h4 id="二、Garmin-Connect"><a href="#二、Garmin-Connect" class="headerlink" title="二、Garmin Connect"></a><strong>二、Garmin Connect</strong></h4><p>这个是佳明手表提供的平台：</p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/running-11.png" alt="image-20250505104237203" style="zoom:33%;"><p>同时，你也可以分享你的个人资料，比如下面是我个人的资料：</p><ul><li><a href="https://connect.garmin.cn/modern/profile/1fbb8b4a-ba06-4c4a-bd9b-fc29524ec46f" target="_blank" rel="noopener">https://connect.garmin.cn/modern/profile/1fbb8b4a-ba06-4c4a-bd9b-fc29524ec46f</a></li></ul><blockquote><p>  <strong>佳明平台是分中国区和国际区的，数据是不同步的！</strong></p><p>  <strong>你可以使用下面这个仓库同步：</strong></p><ul><li><a href="https://github.com/gooin/dailysync-rev" target="_blank" rel="noopener">https://github.com/gooin/dailysync-rev</a></li></ul></blockquote><br><h4 id="三、Strava"><a href="#三、Strava" class="headerlink" title="三、Strava"></a><strong>三、Strava</strong></h4><p>Strave 是一个跑步运动的平台，许多的大牛都在这个平台上；</p><blockquote><p>  <strong>国内可能无法访问！</strong></p></blockquote><p>你可以在这个平台关注一些你喜欢的跑者、运动员，看他们每天的训练内容、计划等等！</p><p>下面是我的个人网站：</p><ul><li><a href="https://www.strava.com/athletes/145491210" target="_blank" rel="noopener">https://www.strava.com/athletes/145491210</a></li></ul><blockquote><p>  Strava 中可以配置从其他平台同步数据（比如：佳明）！</p><p>  <strong>当然，只能同步国际区的佳明数据，可以通过上面介绍的同步国际区的方式同步数据1</strong></p></blockquote><br><h3 id="博主"><a href="#博主" class="headerlink" title="博主"></a><strong>博主</strong></h3><p>这里我比较关注的有：</p><ul><li><a href="https://space.bilibili.com/38995440" target="_blank" rel="noopener">黑影儿TV</a>：跑过100km！</li><li><a href="https://x.com/yihong0618" target="_blank" rel="noopener">yihong0618</a>：坚持跑步好多年的大佬，RunningPage的作者</li><li></li></ul><blockquote><p>  其他：</p><ul><li><a href="https://www.reddit.com/r/AdvancedRunning/comments/1aiugyx/running_influencers/?tl=zh-hans" target="_blank" rel="noopener">https://www.reddit.com/r/AdvancedRunning/comments/1aiugyx/running_influencers/?tl=zh-hans</a></li></ul></blockquote><br><h3 id="装备"><a href="#装备" class="headerlink" title="装备"></a><strong>装备</strong></h3><ul><li>手表/手环：佳明、高驰、华为、小米都可以</li><li>手机</li><li>一双好的运动鞋</li></ul><br><h3 id="动漫书籍"><a href="#动漫书籍" class="headerlink" title="动漫书籍"></a><strong>动漫书籍</strong></h3><p>动漫、电影、书籍都推荐：强风吹拂：</p><ul><li><a href="https://movie.douban.com/subject/30238385/" target="_blank" rel="noopener">《風が強く吹いている》</a></li></ul><br><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h2><p>最后，说了这么多，实际上：<strong>一切的理论、装备都不如一份坚持重要。</strong></p><p>我最近参加了几个业余组的比赛就发现：</p><p>比赛刚开始的时候，大家都是兴致勃勃，但是超过一公里之后的每一段距离，都有一部分选手选择停下来；</p><p>但是对于长跑来说：</p><p><font color="#f00"><strong>重要的实际上并不是最开始或者最后的一公里，而是在开始前确定一个恒定的速度，然后按照这个恒定的速度一直坚持跑下去，像机器一样、节奏一直恒定的运行。</strong></font></p><p><strong>最后，也祝各位读者能够身体健康，每天突破自己的 PB！🎉</strong></p><br>]]></content>
    
    
    <summary type="html">不知不觉跑步已经锻炼了有一年时间了，从最开始200米都跑不下来，到现在跑完半马，变化还是巨大的。本文记录一些跑步的感想。</summary>
    
    
    
    <category term="人生日记" scheme="https://jasonkayzk.github.io/categories/人生日记/"/>
    
    
    <category term="人生日记" scheme="https://jasonkayzk.github.io/tags/人生日记/"/>
    
  </entry>
  
  <entry>
    <title>通过GithubActions拉取并推送Docker镜像到国内云</title>
    <link href="https://jasonkayzk.github.io/2025/01/30/%E9%80%9A%E8%BF%87GithubActions%E6%8B%89%E5%8F%96%E5%B9%B6%E6%8E%A8%E9%80%81Docker%E9%95%9C%E5%83%8F%E5%88%B0%E5%9B%BD%E5%86%85%E4%BA%91/"/>
    <id>https://jasonkayzk.github.io/2025/01/30/%E9%80%9A%E8%BF%87GithubActions%E6%8B%89%E5%8F%96%E5%B9%B6%E6%8E%A8%E9%80%81Docker%E9%95%9C%E5%83%8F%E5%88%B0%E5%9B%BD%E5%86%85%E4%BA%91/</id>
    <published>2025-01-30T03:13:54.000Z</published>
    <updated>2025-07-30T10:34:36.229Z</updated>
    
    <content type="html"><![CDATA[<p>自从DockerHub在国内被墙之后，Docker镜像在国内的拉取一直是一个问题。目前有许多解决方案，比如：使用公开的镜像站、或者通过Cloudflare自建镜像站等等。但是都存在访问不稳定、配置麻烦等问题。</p><p>实际上，Github提供的Actions服务器就是在海外，可以通过Actions拉取Docker镜像，并推送到国内的云厂商，实现稳定的访问！</p><p><a href="https://github.com/tech-shrimp/docker_image_pusher" target="_blank" rel="noopener">tech-shrimp/docker_image_pusher</a> 库就实现了这个功能！</p><br><a id="more"></a><h1 id="通过GithubActions拉取并推送Docker镜像到国内云"><a href="#通过GithubActions拉取并推送Docker镜像到国内云" class="headerlink" title="通过GithubActions拉取并推送Docker镜像到国内云"></a><strong>通过GithubActions拉取并推送Docker镜像到国内云</strong></h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><p>首先 fork 项目：</p><ul><li><a href="https://github.com/tech-shrimp/docker_image_pusher" target="_blank" rel="noopener">https://github.com/tech-shrimp/docker_image_pusher</a></li></ul><p>到本地，然后基本上根据 README 文档来即可；</p><p>需要在 fork 后的仓库的配置中配置 Secrets：</p><ul><li>ALIYUN_NAME_SPACE：你创建的阿里云的命名空间</li><li>ALIYUN_REGISTRY：阿里云的地址</li><li>ALIYUN_REGISTRY_USER：阿里云的用户名</li><li>ALIYUN_REGISTRY_PASSWORD：阿里云的密码</li></ul><p><strong>配置完成后直接修改 <code>images.txt</code> 文件即可直接拉取镜像并推送到阿里云的容器仓库！</strong></p><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源码仓库：</p><ul><li><a href="https://github.com/tech-shrimp/docker_image_pusher" target="_blank" rel="noopener">https://github.com/tech-shrimp/docker_image_pusher</a></li></ul><br>]]></content>
    
    
    <summary type="html">自从DockerHub在国内被墙之后，Docker镜像在国内的拉取一直是一个问题。目前有许多解决方案，比如：使用公开的镜像站、或者通过Cloudflare自建镜像站等等。但是都存在访问不稳定、配置麻烦等问题。实际上，Github提供的Actions服务器就是在海外，可以通过Actions拉取Docker镜像，并推送到国内的云厂商，实现稳定的访问！tech-shrimp/docker_image_pusher 库就实现了这个功能！</summary>
    
    
    
    <category term="Docker" scheme="https://jasonkayzk.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://jasonkayzk.github.io/tags/Docker/"/>
    
    <category term="Github" scheme="https://jasonkayzk.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>使用AnythingLLM+SillconFlow+Milvus快速搭建个人云端知识库</title>
    <link href="https://jasonkayzk.github.io/2025/01/29/%E4%BD%BF%E7%94%A8AnythingLLM-SillconFlow-Milvus%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <id>https://jasonkayzk.github.io/2025/01/29/%E4%BD%BF%E7%94%A8AnythingLLM-SillconFlow-Milvus%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%BA%93/</id>
    <published>2025-01-29T05:49:26.000Z</published>
    <updated>2025-07-30T10:34:36.209Z</updated>
    
    <content type="html"><![CDATA[<p>最近DeepSeek如火如荼，由于目前我也有自己搭建个人知识库的需求，因此结合最新的一些技术搭建了一下。主要是包括：</p><ul><li>AnythingLLM平台</li><li>SillconFlow提供免费的大模型API支持</li><li>私有部署的Milvus向量数据库供多个人使用</li></ul><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/docker-repo/blob/master/anything-llm.sh" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/blob/master/anything-llm.sh</a></li><li><a href="https://github.com/JasonkayZK/docker-repo/tree/milvus-standalone" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/tree/milvus-standalone</a></li></ul><br><a id="more"></a><h1 id="使用AnythingLLM-SillconFlow-Milvus快速搭建个人云端知识库"><a href="#使用AnythingLLM-SillconFlow-Milvus快速搭建个人云端知识库" class="headerlink" title="使用AnythingLLM+SillconFlow+Milvus快速搭建个人云端知识库"></a><strong>使用AnythingLLM+SillconFlow+Milvus快速搭建个人云端知识库</strong></h1><p>环境搭建部分完全使用 Docker：</p><p>首先部署 Milvus、然后部署 AnythingLLM 平台，最后注册 SillconFlow 并对平台进行配置。</p><br><h2 id="部署Milvus"><a href="#部署Milvus" class="headerlink" title="部署Milvus"></a><strong>部署Milvus</strong></h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a><strong>部署</strong></h3><p>向量数据库 <a href="https://github.com/milvus-io/milvus" target="_blank" rel="noopener">milvus</a> 的部署比较简单，直接通过 docker-compose 部署即可：</p><pre><code class="yaml">version: &#39;3.5&#39;services:  etcd:    container_name: milvus-etcd    image: quay.io/coreos/etcd:v3.5.16    restart: unless-stopped    environment:      - ETCD_AUTO_COMPACTION_MODE=revision      - ETCD_AUTO_COMPACTION_RETENTION=1000      - ETCD_QUOTA_BACKEND_BYTES=4294967296      - ETCD_SNAPSHOT_COUNT=50000    volumes:      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/etcd:/etcd    command: etcd -advertise-client-urls=http://127.0.0.1:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd    healthcheck:      test: [&quot;CMD&quot;, &quot;etcdctl&quot;, &quot;endpoint&quot;, &quot;health&quot;]      interval: 30s      timeout: 20s      retries: 3  minio:    container_name: milvus-minio    image: registry.cn-hangzhou.aliyuncs.com/jasonkay/minio:RELEASE.2023-03-20T20-16-18Z    restart: unless-stopped    environment:      MINIO_ACCESS_KEY: minioadmin      MINIO_SECRET_KEY: minioadmin    ports:      - &quot;9001:9001&quot;      - &quot;9000:9000&quot;    volumes:      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/minio:/minio_data    command: minio server /minio_data --console-address &quot;:9001&quot;    healthcheck:      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;]      interval: 30s      timeout: 20s      retries: 3  standalone:    container_name: milvus-standalone    image: registry.cn-hangzhou.aliyuncs.com/jasonkay/milvus:v2.5.4    restart: unless-stopped    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;standalone&quot;]    security_opt:    - seccomp:unconfined    environment:      ETCD_ENDPOINTS: etcd:2379      MINIO_ADDRESS: minio:9000    volumes:      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/milvus:/var/lib/milvus    healthcheck:      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9091/healthz&quot;]      interval: 30s      start_period: 90s      timeout: 20s      retries: 3    ports:      - &quot;19530:19530&quot;      - &quot;9091:9091&quot;    depends_on:      - &quot;etcd&quot;      - &quot;minio&quot;networks:  default:    name: milvus</code></pre><blockquote><p>  <strong>镜像使用的是我在阿里云上的，国内也可以直接使用；</strong></p></blockquote><p>使用：</p><pre><code class="shell">docker-compose up -d</code></pre><p>部署即可；</p><br><h3 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a><strong>配置密码</strong></h3><p>部署成功后，Milvus 的默认账号、密码为：</p><pre><code>rootMilvus</code></pre><p>可以通过在部署的时候提供配置文件来配置账号密码，也可以部署后通过 Python 脚本部署；</p><p>例如：</p><pre><code class="python">from pymilvus import MilvusClientclient = MilvusClient(    uri=&#39;http://localhost:19530&#39;, # replace with your own Milvus server address    token=&quot;root:Milvus&quot;)client.update_password(&#39;root&#39;, &#39;Milvus&#39;, &#39;&lt;your-new-password&gt;&#39;, using=&#39;default&#39;)print(client.list_users())</code></pre><blockquote><p>  参考：</p><ul><li><a href="https://www.milvus-io.com/adminGuide/authenticate" target="_blank" rel="noopener">https://www.milvus-io.com/adminGuide/authenticate</a></li></ul></blockquote><br><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a><strong>备注</strong></h3><p>在启动 standalone 类型的服务后， Web 界面会有 etcd unhealthy 的报错。</p><p>这个是正常现象，忽略即可；</p><blockquote><p>  参考：</p><ul><li><a href="https://github.com/milvus-io/milvus/issues/39417" target="_blank" rel="noopener">milvus-io/milvus#39417</a></li></ul></blockquote><br><h2 id="注册SiliconFlow"><a href="#注册SiliconFlow" class="headerlink" title="注册SiliconFlow"></a><strong>注册SiliconFlow</strong></h2><p>SiliconFlow 提供了各种大模型的 API，甚至有许多免费的版本；</p><p>可以通过下面的链接注册：</p><ul><li><a href="https://cloud.siliconflow.cn/i/zA7ywKdU" target="_blank" rel="noopener">https://cloud.siliconflow.cn/i/zA7ywKdU</a></li></ul><blockquote><p>  <strong>链接包含我的邀请码，注册后可额外获得 2000w 的 token 额度。</strong></p></blockquote><p>注册成功后，可以在 <a href="https://cloud.siliconflow.cn/account/ak" target="_blank" rel="noopener">API密钥</a> 生成密钥；</p><blockquote><p>  <strong>保存，后面会用到！</strong></p></blockquote><br><h2 id="部署AnythingLLM"><a href="#部署AnythingLLM" class="headerlink" title="部署AnythingLLM"></a><strong>部署AnythingLLM</strong></h2><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a><strong>部署</strong></h3><p>可以通过 Docker 直接部署 AnythingLLM：</p><pre><code class="bash">export STORAGE_LOCATION=$HOME/workspace/anythingllm &amp;&amp; \mkdir -p $STORAGE_LOCATION &amp;&amp; \touch &quot;$STORAGE_LOCATION/.env&quot; &amp;&amp; \chmod -R 0777 $STORAGE_LOCATION &amp;&amp; \docker run -d -p 3001:3001 \--restart=unless-stopped \--name my-anything-llm \--cap-add SYS_ADMIN \-v ${STORAGE_LOCATION}:/app/server/storage \-v ${STORAGE_LOCATION}/.env:/app/server/.env \-e STORAGE_DIR=&quot;/app/server/storage&quot; \registry.cn-hangzhou.aliyuncs.com/jasonkay/anythingllm:latest</code></pre><p>这里需要注意：</p><p><strong>Docker挂载目录需要给权限 0777，否则可能会报错无权限（尤其是root用户操作）：</strong></p><blockquote><p>  <a href="https://github.com/Mintplex-Labs/anything-llm/issues/2564" target="_blank" rel="noopener">https://github.com/Mintplex-Labs/anything-llm/issues/2564</a></p></blockquote><br><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>在配置 <code>LLM 提供商</code> 时，需要选择：<code>Generic OpenAI</code> 才能使用我们在 SiliconFlow 中的模型，随后配置：</p><ul><li>Base URL：<a href="https://api.siliconflow.cn" target="_blank" rel="noopener">https://api.siliconflow.cn</a></li><li>API Key：你上面生成的API密钥</li><li>Chat Model Name：可在 <a href="https://cloud.siliconflow.cn/models" target="_blank" rel="noopener">https://cloud.siliconflow.cn/models</a> 查找免费的模型（例如：<code>Qwen/Qwen2.5-7B-Instruct</code>）</li></ul><br><p>在配置向量数据库时，可以直接使用 AnythingLLM 中内嵌的 LanceDB，此时无需配置；</p><p>当然，也可以使用我们上面已经部署好的 Milvus 数据库；</p><p>此时，只需要配置：</p><ul><li>Milvus DB Address：<a href="http://172.17.0.1" target="_blank" rel="noopener">http://172.17.0.1</a> （可以使用 Docker 的gateway，也可以用其他的）</li><li>Username、Password：使用你配置的或者默认的即可！</li></ul><br><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a><strong>加载模型</strong></h3><p>上面配置完成后，即可正常使用对话功能；</p><p>但是，如果想要通过上传文档、图片等形成个人知识库，则还需要对数据进行向量化等操作，此时需要加载模型；</p><p>在没有挂梯子的情况下，在上传文档时会报错：<code>fetch-failed-on-upload</code>：</p><ul><li><a href="https://docs.anythingllm.com/fetch-failed-on-upload#windows-visual-c-redistributable" target="_blank" rel="noopener">https://docs.anythingllm.com/fetch-failed-on-upload#windows-visual-c-redistributable</a></li><li><a href="https://github.com/Mintplex-Labs/anything-llm/issues/821#issuecomment-1968382359" target="_blank" rel="noopener">https://github.com/Mintplex-Labs/anything-llm/issues/821#issuecomment-1968382359</a></li></ul><p>此时大概率是一位模型无法下载；</p><p>可以通过手动下载并加载的方式来解决：</p><blockquote><p>  参考：</p><ul><li><a href="https://github.com/JasonkayZK/docker-repo/issues/4" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/issues/4</a></li></ul></blockquote><p>首先，在 <code>&lt;your-anythingllm-path&gt;/models/</code> 目录下创建 <code>Xenova</code> 目录；</p><p>随后下载模型压缩包，并上传到这个目录下：</p><ul><li><a href="https://github.com/user-attachments/files/18596293/all-MiniLM-L6-v2.zip" target="_blank" rel="noopener">all-MiniLM-L6-v2.zip</a></li></ul><p>最后解压缩即可：</p><pre><code class="bash">unzip all-MiniLM-L6-v2.zip</code></pre><p>解压缩完成后效果：</p><pre><code>root@VM-12-16-debian:~/workspace/anythingllm/models/Xenova# tree ..└── all-MiniLM-L6-v2    ├── config.json    ├── onnx    │   └── model_quantized.onnx    ├── tokenizer_config.json    └── tokenizer.json2 directories, 4 files</code></pre><br><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a><strong>功能测试</strong></h2><p>全部部署完成后，可以创建新的工作区，并且在工作区中创建 thread 进行新的对话；</p><p>同时在工作区中也可以上传文档，在对话时，AnythingLLM 会首先根据你的问题，在向量数据库中匹配，随后发给大模型作为 prompt 来生成对应回答！</p><br><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>除了使用 Docker 来部署 AnythingLLM 之外，也提供了桌面的版本；</p><p>Desktop 版本和 Web 版的配置非常类似，这里不再赘述！</p><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/docker-repo/blob/master/anything-llm.sh" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/blob/master/anything-llm.sh</a></li><li><a href="https://github.com/JasonkayZK/docker-repo/tree/milvus-standalone" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/tree/milvus-standalone</a></li></ul><br>]]></content>
    
    
    <summary type="html">最近DeepSeek如火如荼，由于目前我也有自己搭建个人知识库的需求，因此结合最新的一些技术搭建了一下。主要是包括AnythingLLM平台、SillconFlow提供免费的大模型API支持、私有部署的Milvus向量数据库供多个人使用！</summary>
    
    
    
    <category term="人工智能" scheme="https://jasonkayzk.github.io/categories/人工智能/"/>
    
    
    <category term="Docker" scheme="https://jasonkayzk.github.io/tags/Docker/"/>
    
    <category term="人工智能" scheme="https://jasonkayzk.github.io/tags/人工智能/"/>
    
  </entry>
  
  <entry>
    <title>【顶】さよなら２０２４、こんにちは２０２５！</title>
    <link href="https://jasonkayzk.github.io/2025/01/17/%E3%80%90%E9%A1%B6%E3%80%91%E3%81%95%E3%82%88%E3%81%AA%E3%82%89%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%94%E3%80%81%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%95%EF%BC%81/"/>
    <id>https://jasonkayzk.github.io/2025/01/17/%E3%80%90%E9%A1%B6%E3%80%91%E3%81%95%E3%82%88%E3%81%AA%E3%82%89%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%94%E3%80%81%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%EF%BC%92%EF%BC%90%EF%BC%92%EF%BC%95%EF%BC%81/</id>
    <published>2025-01-17T05:45:11.000Z</published>
    <updated>2025-07-30T10:34:36.207Z</updated>
    
    <content type="html"><![CDATA[<p>又是新的一年了，最近放寒假，终于能抽出时间来总结一下2024年、再展望一下2025年！</p><br><a id="more"></a><h1 id="【顶】さよなら２０２４、こんにちは２０２５！"><a href="#【顶】さよなら２０２４、こんにちは２０２５！" class="headerlink" title="【顶】さよなら２０２４、こんにちは２０２５！"></a><strong>【顶】さよなら２０２４、こんにちは２０２５！</strong></h1><h2 id="さよなら２０２４！"><a href="#さよなら２０２４！" class="headerlink" title="さよなら２０２４！"></a><strong>さよなら２０２４！</strong></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>2024年对我个人来说，是转变极大的一年。</p><p>在这一年，我彻底放弃了程序员的职业，转而回家考取体制内，最终在八月份成为了一名家乡大专的计算机专业的老师。</p><p>除了职业上的转变，实际上也包含了心态上的转变。</p><p>在2024年的上半年，实际上花了很长时间继续去做一些技术上的突破，比如：</p><ul><li>学习了一些数据存储的格式，例如：bamboo；</li><li>学习了分布式系统相关的时钟逻辑，也用 rust 实现了一个：merkle-trie-clock；</li><li>学习了 CRDTs 相关的内容，用 rust 写了一个简单的 CRDTs 的demo；</li><li>看了数据库内核的相关实现，打算尝试去写一个基于 CRDTs 理论的分布式数据库；</li><li>……</li></ul><p>但是，后面发现对于技术的热情实际上是有所下降的。</p><blockquote><p>  <strong>与其说是对于技术的热情有所下降，不如说是更多是想分享知识，而非单纯的研究技术；</strong></p></blockquote><br><p>当然，除了研究技术之外，上半年也准备了一下考试。</p><blockquote><p>  别忘了，我是学电气工程出身的！</p></blockquote><p>为了准备相关的考试，又重新复习了一下电气工程的相关书，包括：</p><ul><li>电网招聘考试书</li><li>注册电气工程师</li><li>原来本科的书</li><li>行测等</li><li>……</li></ul><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/%E7%94%B5%E6%B0%94%E5%A4%8D%E4%B9%A0.jpg" alt="电气复习.jpg"></p><p>最后也是通过笔试第二、面试第一成功选择了学校的岗位。</p><blockquote><p>  <strong>有些人可能会奇怪，电气工程专业为啥当上了计算机的老师；</strong></p><p>  <strong>实际上我在去学校报道的时候，正好碰到了计算机学院的院长，然后就被拉到了计算机学院😁，巧了！</strong></p></blockquote><br><h3 id="学校生活"><a href="#学校生活" class="headerlink" title="学校生活"></a><strong>学校生活</strong></h3><p>八月份入职之前，其实提前准备了一些教师相关的东西，比如：</p><ul><li>如何备课</li><li>如何上好一门课</li><li>上课期间站姿、手势、仪态等等</li></ul><p>但实际上刚入职的老师会被要求担任辅导员；</p><br><h4 id="辅导员"><a href="#辅导员" class="headerlink" title="辅导员"></a><strong>辅导员</strong></h4><p>作为初入学校的「しろうと」来说，辅导员的挑战实际上是有的。</p><p>对于2024年新入学的学生来说，大致是在06年出生，和我相差大概10岁左右。</p><blockquote><p>  <strong>但是实际上，辅导员算是一个半管理岗位，为啥说是“半”呢？</strong></p><p>  <strong>因为，每天一睁眼，几十号人的吃喝拉撒基本上都要你管！</strong></p></blockquote><p>但是实际上会有些紧张，这个紧张一方面是：和一群「歳下」 的孩子们接触：</p><ul><li>如何和这些同学接触？</li><li>如何融入学生？</li><li>进一步，如何管理这些学生？（达成共识？解决冲突？）</li></ul><blockquote><p>  <strong>实际上，这些工作和程序员的工作思路是完全不同的事情！</strong></p></blockquote><p>另一方面是：如何正确的引导这些学生？</p><ul><li>思想上</li><li>三观上</li></ul><p>我自以为，老师和其他相关的职业有一个很大的不同在于：</p><p><font color="#f00"><strong>一个好的老师真的可以拯救学生，而一个不负责任的老师真的也能毁掉无数个学生</strong></font></p><blockquote><p>  <strong>我自认为自己还算是一个做事负责任的人吧！</strong></p></blockquote><p>实际上你的言行真的会影响到很多学生、尤其是刚刚成年的学生未来的三观。</p><p>但是对于如何做，实际上当时我是毫无头绪的！</p><p>但是当时我给自己定下了一个最低的底线：</p><ul><li><font color="#f00"><strong>一定不要成为自己最讨厌的那种老师！</strong></font></li></ul><blockquote><p>  <strong>现在看来，这个底线实际上也并不低！</strong></p></blockquote><br><h5 id="首次接触学生"><a href="#首次接触学生" class="headerlink" title="首次接触学生"></a><strong>首次接触学生</strong></h5><p>我第一次接触学生实际上是在新生报道之前。</p><p>因为我之前是程序员的缘故，接触过不少云计算相关的内容，所以我的导师王老师让我来带一带竞赛的学生；</p><blockquote><p>  <strong>实际上这个决定让我首先小范围的接触了几位同学；</strong></p><p>  <strong>对我后面工作的开展获益匪浅；</strong></p></blockquote><p>所以，在还没开学之前就了解了目前这个年龄段的学生脑子里想的是什么，学生的层次、一些学校的规则制度、运行模式等等。</p><p>同时也能够小范围的先锻炼锻炼自己的表达能力…</p><blockquote><p>  <strong>关于竞赛的事情，后文再继续聊～</strong></p></blockquote><br><h5 id="迎新活动"><a href="#迎新活动" class="headerlink" title="迎新活动"></a><strong>迎新活动</strong></h5><p>当新生辅导员的第一件事实际上是为全班的新生建群。</p><p>好在我带的班学生都比较积极，基本上一天之内就建好了！</p><p>到了24级正式开学的时候，实际上今年一共招了将近900号学生，要对这些学生进行信息采集、确认；</p><p>当时在学院楼外面坐了整整两天，说话说的嗓子都要哑了，最后也是顺利的把这些熊孩子给安置好了。</p><br><h5 id="第一次带军训"><a href="#第一次带军训" class="headerlink" title="第一次带军训"></a><strong>第一次带军训</strong></h5><p>迎新结束之后，马不停蹄的就是学生的军训；</p><p>比起我当年的军训，个人觉得00后的军训强度要低太多了；</p><p>可能是身体素质整体都下滑，军训还没开始，刚刚站了十几分钟就已经有晕倒的了。</p><p>我带的班，军训的两个星期也是请假无数……；</p><p>总而言之，身体素质在00后这一代真的堪忧……。</p><br><h5 id="第一次班会"><a href="#第一次班会" class="headerlink" title="第一次班会"></a><strong>第一次班会</strong></h5><p>在军训期间，要开一个班会，和班里的同学都见见面。</p><p>这也是我第一次以辅导员的身份站在讲台上；</p><p>其实刚开始还是有些紧张的，毕竟下面坐着几十个完全不认识的熊孩子；</p><p>需要做的实际上是提前准备班会的内容，可以先记在笔记本上，然后带过去讲就行；</p><blockquote><p>  <strong>后面发现，站上去之后讲的挺自然的，就不紧张了…</strong></p><p>  <strong>当然，现在在上面时间长了，早就没什么感觉了…</strong></p></blockquote><br><h5 id="第一次出差"><a href="#第一次出差" class="headerlink" title="第一次出差"></a><strong>第一次出差</strong></h5><p>在九月底还没到十月份的时候，接到了通知要带几个学生去开封参加比赛，这也是我第一次带学生外出比赛；</p><p>比较好的是，来回的路途是由市政府安排的专车接送，所以不需要提前订票了；</p><p>但是当时的酒店我们希望能拼房，所以出来不小的问题，就是和我们拼房的人提前3天走了，导致我们无房可拼；</p><p>不过后面也是找到了开封市的人社局给解决了；</p><p>本次比赛的成绩可以说是非常惨淡：<strong>参与了3个赛项，无一获奖！</strong></p><p>实际上一个比较关键的原因是：竞赛的学生基本上都是靠自己自学，而没有老师带！</p><p>这些学生会浪费大量的时间在寻找学习材料和学习路径上，这是很可怕的事情！</p><blockquote><p>  <strong>这也让我感受到了，学校的竞赛之路，任重而道远啊！</strong></p></blockquote><br><h5 id="一些其他的碎碎念"><a href="#一些其他的碎碎念" class="headerlink" title="一些其他的碎碎念"></a><strong>一些其他的碎碎念</strong></h5><p>除了上面的事情之外，实际上还有很多其他的事情，下面就简单列出一部分：</p><ul><li>学生宿舍值班</li><li>学生日常请假管理</li><li>学生心理问题排查</li><li>班级活动组织</li><li>……</li></ul><p>最后想再说一下：</p><p>我最开始以为，来到大专的学生大多数是对学习毫无兴趣的学生；</p><p>但是后面接触之后我发现，实际上这里大多数学生都来自农村、乡镇（至少我班里只有4、5个是城市户口）；</p><p>他们先天就没有特别好的教育环境。</p><p>以我带的竞赛的一个学生为例：这个学生白天的时候要去干农活、晚上在家做完饭之后，才能抽出时间来学习云计算；</p><p>我当时听完之后感觉到挺不可思议的。</p><blockquote><p>  <strong>当时我还戏称自己是“上山下乡”……</strong></p></blockquote><br><h4 id="教学"><a href="#教学" class="headerlink" title="教学"></a><strong>教学</strong></h4><h5 id="竞赛培训"><a href="#竞赛培训" class="headerlink" title="竞赛培训"></a><strong>竞赛培训</strong></h5><p>作为一个老师而言，其实最基本的一个工作就是讲课；</p><p>分享的经验实际上在之前当程序员的时候是有的，当时有大量的技术分享会，而且我也参与过一次线上的直播分享；</p><p>但是实际上对于这些学生的水平，我是拿不准的，不知道这些学生对于知识的掌握程度，这个是很致命的！</p><p>好在有个学生掌握的还可以，但是没有老师带，实际上还是挺吃力的，一直在自己部署 OpenStack，对于 Docker、K8S 都不知道是什么；</p><p>我也是从 Github、git、一路讲到 Docker！</p><blockquote><p>  <strong>实际上，如果真正感兴趣、用心学的学生，他的学习能力是惊人的！</strong></p></blockquote><p>最后也是拿了省二等和国家三等奖的成绩。</p><blockquote><p>  <strong>实际上这个成绩只是个开始，后面还要继续努力！</strong></p></blockquote><br><h5 id="第一次试讲"><a href="#第一次试讲" class="headerlink" title="第一次试讲"></a><strong>第一次试讲</strong></h5><p>关于这个试讲，这里说一下。</p><p>新入职的老师是不会直接参与讲课的，只有通过了：教研室、系部、学校，三个阶段的试讲才能上课。</p><p>试讲的内容是自己选择一门最拿手的课程，然后进行无生试讲，大概 15 分钟左右。</p><p>我的试讲内容实际上是云计算，讲的 Docker。</p><p>由于没有什么经验，同时备课准备的实际上不是很充分，所以课讲的稀烂……</p><blockquote><p>  <strong>甚至讲课的状态是我最讨厌的念 PPT 的方式……！</strong></p></blockquote><p>当时主任给我提了很多很实用的整改意见，我这里大概总结了几条：</p><ul><li><strong>PPT 的内容应该少文章多图片，这样比较生动；</strong></li><li><strong>讲课的时候应该多举一些生活中的例子，而不只是念ppt的内容；</strong></li><li><strong>在讲的过程中，声音应当抑扬顿挫，有节奏，类似于唱歌；</strong></li><li>……</li></ul><blockquote><p>  <font color="#f00"><strong>这里非常感谢主任给我提的这些意见，让我在后面找到了讲课的方向，慢慢摸索出了如何讲课！</strong></font></p><p>  <font color="#f00"><strong>实际上还有另外一个问题，就是：当时我刚来的时候就是给参与竞赛的学生讲，但是这些学生实际上水平、学习热情是远远高于一般的学生的！</strong></font></p><p>  <font color="#f00"><strong>实际上这也导致了，后面在真正上课的时候，一开始上课的内容实际上学生并不能很好的掌握（甚至部分学生别崩溃）！</strong></font></p></blockquote><p>后面，由于第一次试讲讲的并不是很好，所以后面又陆陆续续讲了几次试讲，进步其实是很明显的！</p><br><h5 id="新生分享、社团分享"><a href="#新生分享、社团分享" class="headerlink" title="新生分享、社团分享"></a><strong>新生分享、社团分享</strong></h5><p>在第二次试讲之前，为了锻炼一下自己的讲课能力，参与了一些其他课程的讲授。</p><p>主要是几次的新生分享：</p><p>第一次是给24级新来的计算机专业的新生讲解目前一些新的主流技术，比如：云计算、大数据、人工智能相关的内容；</p><p>第二次是给学校的本科学生讲解：大学时间规划、考研等相关的内容；</p><p>相比于第一次分享，第二次是受到学校的另一个学院的院长邀请，形式上也比较正式，是在学校图书馆一楼的报告厅，大概有几百号学生参与；</p><p>实际上准备的并不是很充分，但是不知道是不是因为讲的都是自己的经历，反而没什么可紧张的，讲的过程也很顺利。</p><blockquote><p>  <strong>实际上，在台上看到下面坐着的许多学生心里还是几多感慨：</strong></p><p>  <strong>大概十年前，我和他们是一样的迷茫，不知道自己何去何从，不知道自己要干什么……</strong></p><p>  <strong>所以当时，上台之前，我想做的实际上就是分享自己的经历，包括好的和坏的。让这些学生有所借鉴，能走出属于这些孩子自己的一条路！</strong></p></blockquote><br><p>同时，由于我是学校计算机社团的指导老师，在后面也给社团讲了一次课（大概2个小时的时间）。</p><p>主要是分享（或者说科普）一些计算机相关的内容。</p><p>来参与的学生实际上并不只是计算机专业的学生，但是除了基础的 Python 之外，我还是讲了一些其他的内容。</p><p>比如：</p><ul><li>人工智能的基本使用方法；</li><li>Github 网站</li><li>一些写代码的工具</li><li>……</li></ul><blockquote><p>  <strong>基本上每次分享，我都要讲上面的一些内容；</strong></p><p>  <strong>尤其是 Github，我觉得如果从事计算机专业，这个网站是必须要知道的！</strong></p><p>  <strong>但是国内很多高校的学生，甚至到毕业都不知道这个网站！</strong></p><p>  <strong>个人觉得，学会并使用 Github 是从事计算机行业最基本的一项内容！</strong></p></blockquote><br><h5 id="第二次试讲"><a href="#第二次试讲" class="headerlink" title="第二次试讲"></a><strong>第二次试讲</strong></h5><p>第二次试讲来的比较匆忙，从通知到试讲实际上就间隔了两三天时间。</p><p>并且由于和之前第一次试讲间隔了太长的时间，实际上之前试讲的内容都忘的差不多了。</p><p>好在 “瘦死的骆驼比马大”！</p><p>所以最后还是顺利的拿下了。</p><p>当然，当时院长也提出了不少的意见，比如：</p><ul><li>讲课过程中，动作太多，一直来回走</li><li>PPT 的标题不统一</li><li>……</li></ul><br><h5 id="紧急代课！"><a href="#紧急代课！" class="headerlink" title="紧急代课！"></a><strong>紧急代课！</strong></h5><p>十一月底的时候，由于有一位老师提前走了，他这学期有两门课需要我临时带，所以强度突然上来！</p><p>当时是周五的晚上通知我，下周一就要上课了！</p><p>由于是第一次正式上课，很多规矩都还不清楚，而且当时是临时代课，还不知道之前的内容。</p><p>所以花了一些时间将要做的按照先后顺序事情归了一下类：</p><ul><li>添加原来的老师、班委，询问课程进度</li><li>拿之前老师的教学资料</li><li>提前备课</li><li>询问上课的流程（包括如何签到、课前的点名、下课的内容等等）</li><li>……</li></ul><p>比较巧的是，我带的其中有一门课，在还没开学的时候，提前备过课，所以可以直接拿过来讲。</p><p>所以第一节课实际上马马虎虎，没有讲什么具体的操作内容，主要是对大数据的技术做了一个科普。</p><br><p>但是后面的课程实际上是出了一些小状况的：</p><p>1、由于这些学生之前的基础没有打好，所以导致我在讲课的时候，班里一大半的学生根本不知道如何实操！</p><blockquote><p>  <strong>实际上，使用到的都是一些非常讲的的 Shell 命令！</strong></p><p>  <strong>对于我之前带的竞赛的学生来说是非常简单的，但是对于来上课的普通学生来说，感觉比登天还难！</strong></p></blockquote><p>所以后面又先带着“复习”了一下 Linux 的内容。</p><br><p>2、另外一个状况是：在机房里面，实际上是没有部署相应的软件的，所以学生没办法跟着一起练习！</p><p>所以，我专门抽了一个下午的时间，做了一个 VMWare 的镜像给到学生，让学生们可以直接通过这个镜像练习！</p><blockquote><p>  最开始我做的是一个无图形界面的系统，但是发现这些学生不会用……</p><p>  所以没办法，又做了一个 Desktop 版本的……</p></blockquote><p>不管怎么样，最后也是把课、期末考试、教学材料跌跌撞撞的走完了！</p><p>虽然比较生涩，但是确实把：</p><ul><li>如何上课</li><li>如何设计课程</li><li>如何设计期末考试</li><li>如何整理教学材料</li><li>……</li></ul><p>在高强度之下快速的摸清楚了！</p><br><h5 id="第三次试讲"><a href="#第三次试讲" class="headerlink" title="第三次试讲"></a><strong>第三次试讲</strong></h5><p>第三次试讲是由学校来组织的，来参与的都是新老师，但是还是收获满满。</p><p>我由于之前的很多经历，准备的比较充分，所以没什么可紧张的。</p><p>但是，在听其他老师试讲的过程中，实际上发现自己和他们还是有非常大的差距的！</p><p>尤其是有几个音乐专业的老师，讲的生动形象，我和他们比起来可以说是相形见绌……</p><blockquote><p>  <strong>并且，我在试讲的时候，写板书写了一分多钟，被评委给吐槽了……</strong></p></blockquote><br><h3 id="一些工作上的总结"><a href="#一些工作上的总结" class="headerlink" title="一些工作上的总结"></a><strong>一些工作上的总结</strong></h3><h4 id="一些心得和分享"><a href="#一些心得和分享" class="headerlink" title="一些心得和分享"></a><strong>一些心得和分享</strong></h4><p>上面是半个学期的一些工作内容。实际上，除了上面列出的一些工作之外，还有很多其他的工作没有列出来。</p><p>可以说，虽然是一个新的老师，但是工作还是非常充实的！</p><p>下面列一些我觉得这学期工作的时候，比较实用的一些技巧和心得。</p><br><h5 id="待办清单（小米云服务）"><a href="#待办清单（小米云服务）" class="headerlink" title="待办清单（小米云服务）"></a><strong>待办清单（小米云服务）</strong></h5><blockquote><p>  <strong>这个是我目前为止，基本上离不开的一个东西！</strong></p></blockquote><p>因为辅导员的事情实际上是非常多的，基本上每次开会都要安排十几件事情！</p><p>如果没有个待办清单，很多事情都会忘掉！</p><p>我之前尝试过一些其他的 TODO 应用，但是感觉还没有小米自带的好用。</p><p>小米的待办清单在 Windows 上有 <code>MIUI+</code> 可以同步，但是我用的是 Mac，没有这个软件。</p><p>但是有一个 <code>小米云服务</code>，所以可以曲线救国，用这个！</p><blockquote><p>  <strong>这里面唯一一个我用的功能就是待办清单！</strong></p><p>  顺便吐槽一下，MIUI+ 说了好多年适配 Mac 了，到现在还没有做出来……</p></blockquote><br><h5 id="和学生打交道"><a href="#和学生打交道" class="headerlink" title="和学生打交道"></a><strong>和学生打交道</strong></h5><p>有的人可能会对辅导员这个职业比较抗拒，但是实际上我倒是觉得这是为数不多比较暖心的工作了…</p><p>可能是因为我和这些孩子们的年龄差距不大，所以并没有那么多代沟，所以沟通起来还是比较轻松的。</p><p>而且也都经历过学生时代，对于这些学生心里是怎么想的、比较反感的东西实际上是一清二楚的。</p><p>当时给自己定的目标就是：</p><ul><li><strong>从群众中来，到群众中去！</strong></li><li><strong>学生们的事情尽量身体力行的去做！</strong></li><li><strong>不要成为自己讨厌的那一类辅导员！</strong></li></ul><p>基本上每周六晚上我值班的时候，都会和班里的学生打打篮球。</p><p>然后时不时的在班级群里吹吹牛啥的，也挺欢乐。</p><p>但是确实，有的事情确实是没有办法，dddd……</p><br><h5 id="讲课"><a href="#讲课" class="headerlink" title="讲课"></a><strong>讲课</strong></h5><p>对于讲课来说，是一个老师的基本功。</p><p>一个感受比较深的点就是：</p><p><strong>一定要备课！</strong></p><p><strong>一定要备课！</strong></p><p><strong>一定要备课！</strong></p><blockquote><p>  <strong>不备课的课和备过课的课上起来是完全不一样的！</strong></p></blockquote><p>备课的时候，主要是记一下这节课的主要大纲，有哪些重点难点什么的。</p><p>然后就是提前准备一些和课程有关的例子，如果不熟悉可以提前先打印出来，然后用笔标注一下。</p><blockquote><p>  <strong>认真备课之后，讲出来的东西可能才是你想要表达的；</strong></p><p>  <strong>如果不备课，虽然很多东西都是你用到的很基础的内容，当时实际上有的时候也很难讲出来！</strong></p></blockquote><p>我刚来学校的时候，主任和我分享的一句话就是：</p><p><font color="#f00"><strong>备课实际上是备学生，你要了解你上课的班的学生的整体状态！</strong></font></p><br><h4 id="需要继续加强的地方"><a href="#需要继续加强的地方" class="headerlink" title="需要继续加强的地方"></a><strong>需要继续加强的地方</strong></h4><p>首先就是做事方面：</p><p>很多事情不懂得推脱，基本上只要有能帮忙的地方，都会去揽活来做，把自己搞得比较累。</p><p>有些时候如果自己比较忙，实际上是可以拒绝的！</p><br><p>另外就是讲课方面：</p><p>基本上现在很多课程都还需要很长的时间备课，同时讲课的能力方面实际上还有很大的进步空间。</p><br><p>心态方面：</p><p>很多事情在做的时候，还是会比较急，心态容易出问题。</p><p>这可能在未来的工作中还需要进一步沉淀沉淀！</p><br><h2 id="こんにちは２０２５！"><a href="#こんにちは２０２５！" class="headerlink" title="こんにちは２０２５！"></a><strong>こんにちは２０２５！</strong></h2><p>聊完了已经过去的 2024 年，下面是我对于 2025 年的一些规划：</p><ul><li><p>证书：</p><ul><li><input checked disabled type="checkbox"> <p>高校教师资格证 + 普通话证</p></li><li><input disabled type="checkbox"> <p>通过软考中级（软件设计师）</p></li><li><input disabled type="checkbox"> <p>日语N2证书</p></li><li><input disabled type="checkbox"> <p>雅思证书（待定）</p></li></ul></li><li><p>跑步：</p><ul><li><input disabled type="checkbox"> 年跑量 1000km</li><li><input disabled type="checkbox"> 参加一次半马</li></ul></li><li><p>旅游：</p><ul><li><input disabled type="checkbox"> 去一次日本旅游</li></ul></li><li><p>购物：</p><ul><li><input disabled type="checkbox"> 40系 N 卡</li><li><input checked disabled type="checkbox"> 佳明 255 跑表</li></ul></li></ul><p>内容可能不是很多，但是是一些目前我能够想到的东西；</p><p>如果后面有新加入的内容，也会再加进来！</p><p>最后，祝愿各位在新的一年都能顺顺利利，无限进步！</p><p><strong>今年も、よろしくお願いします！</strong></p><br>]]></content>
    
    
    <summary type="html">又是新的一年了，最近放寒假，终于能抽出时间来总结一下2024年、再展望一下2025年！</summary>
    
    
    
    <category term="人生日记" scheme="https://jasonkayzk.github.io/categories/人生日记/"/>
    
    
    <category term="人生日记" scheme="https://jasonkayzk.github.io/tags/人生日记/"/>
    
  </entry>
  
  <entry>
    <title>Excel通过身份证号列计算性别</title>
    <link href="https://jasonkayzk.github.io/2024/09/11/Excel%E9%80%9A%E8%BF%87%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E5%88%97%E8%AE%A1%E7%AE%97%E6%80%A7%E5%88%AB/"/>
    <id>https://jasonkayzk.github.io/2024/09/11/Excel%E9%80%9A%E8%BF%87%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E5%88%97%E8%AE%A1%E7%AE%97%E6%80%A7%E5%88%AB/</id>
    <published>2024-09-11T02:28:56.000Z</published>
    <updated>2025-07-30T10:34:36.185Z</updated>
    
    <content type="html"><![CDATA[<p>Excel统计信息中有身份证号，可以通过身份证号直接生成性别列；</p><br><a id="more"></a><h1 id="Excel通过身份证号列计算性别"><a href="#Excel通过身份证号列计算性别" class="headerlink" title="Excel通过身份证号列计算性别"></a><strong>Excel通过身份证号列计算性别</strong></h1><p>例如，B2 列为身份证号所在列，则可以在性别列（如D2列）填写：</p><pre><code>=IF(MOD(MID(B2, 17, 1), 2) = 1, &quot;男&quot;, &quot;女&quot;)</code></pre><p>输入后回车计算结果即为性别；</p><p>可以下拉直接生成全部结果！</p><br><p>参考：</p><ul><li><a href="https://jingyan.baidu.com/article/5553fa8291d46b65a2393432.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/5553fa8291d46b65a2393432.html</a></li></ul><br>]]></content>
    
    
    <summary type="html">Excel统计信息中有身份证号，可以通过身份证号直接生成性别列；</summary>
    
    
    
    <category term="办公" scheme="https://jasonkayzk.github.io/categories/办公/"/>
    
    
    <category term="办公" scheme="https://jasonkayzk.github.io/tags/办公/"/>
    
    <category term="Excel" scheme="https://jasonkayzk.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>开源的个人书籍管理系统Talebook</title>
    <link href="https://jasonkayzk.github.io/2024/08/22/%E5%BC%80%E6%BA%90%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B9%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FTalebook/"/>
    <id>https://jasonkayzk.github.io/2024/08/22/%E5%BC%80%E6%BA%90%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B9%A6%E7%B1%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FTalebook/</id>
    <published>2024-08-22T02:19:57.000Z</published>
    <updated>2025-07-30T10:34:36.220Z</updated>
    
    <content type="html"><![CDATA[<p>我平时看的都是PDF电子书籍，但是之前没有用书籍管理，所以书籍比较乱；</p><p>比较有名的书籍管理系统有Calibre，但是Talebook支持OPDS，同时能从豆瓣导入信息，比较好用；</p><p>本文介绍了如何部署和配置Talebook；</p><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/docker-repo/tree/talebook" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/tree/talebook</a></li></ul><br><a id="more"></a><h1 id="开源的个人书籍管理系统Talebook"><a href="#开源的个人书籍管理系统Talebook" class="headerlink" title="开源的个人书籍管理系统Talebook"></a><strong>开源的个人书籍管理系统Talebook</strong></h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a><strong>部署</strong></h2><p>项目地址如下：</p><ul><li><a href="https://github.com/talebook/talebook" target="_blank" rel="noopener">https://github.com/talebook/talebook</a></li></ul><p>DockerHub地址：</p><ul><li><a href="https://hub.docker.com/r/talebook/talebook" target="_blank" rel="noopener">https://hub.docker.com/r/talebook/talebook</a></li></ul><p>B站上也有UP主对Talebook做了介绍：</p><ul><li><a href="https://www.bilibili.com/video/BV1AT411S7c3/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1AT411S7c3/</a></li></ul><p>部署起来也是非常简单，先把镜像拉下来，然后 docker-compose 就行：</p><p>docker-compose.yml</p><pre><code class="yaml">version: &quot;3&quot;services:  talebook:    container_name: talebook    image: talebook/talebook:v3.8.1    volumes:      - /data/talebook:/data    ports:       - &quot;80:80&quot;       - &quot;443:443&quot;    environment:      - PUID=1000      - PGID=1000      - TZ=Asia/Shanghai      # 调整为『SSR=ON』可开启「服务器端渲染」模式，对于搜索引擎更友好，同时更消耗服务器性能      - SSR=OFF    depends_on:      - douban-rs-api    restart: always  douban-rs-api:    container_name: douban-rs-api    # https://github.com/cxfksword/douban-api-rs    image: ghcr.io/cxfksword/douban-api-rs:latest    restart: always</code></pre><p>配置都比较简单，目录挂载、端口映射直接根据自己的需求修改即可！</p><br><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h2><p>基本的配置，上面的B站UP基本上都讲了；</p><p>需要注意的是：</p><p><font color="#f00"><strong>配置豆瓣的时候，url 结尾的 <code>/</code> 要删除！否则会无法使用！</strong></font></p><blockquote><p>  参考：</p><ul><li><a href="https://github.com/talebook/talebook/issues/340#issuecomment-2097703672" target="_blank" rel="noopener">https://github.com/talebook/talebook/issues/340#issuecomment-2097703672</a></li></ul></blockquote><br><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>支持 OPDS 的 APP 推荐：</p><ul><li>安卓：静读天下</li><li>iOS、MacOS：Yomu、KyBook</li></ul><blockquote><p>  参考：</p><ul><li><a href="https://gameapp.club/post/2022-12-25-ebooks/" target="_blank" rel="noopener">https://gameapp.club/post/2022-12-25-ebooks/</a></li></ul></blockquote><p>需要注意的是：</p><p><strong>如果要使用 OPDS，需要配置：</strong></p><ul><li><strong>关闭「私人图书馆」模式。</strong></li><li><strong>打开「允许任意下载」（访客无需注册或登录）</strong></li></ul><blockquote><p>  参考：</p><ul><li><a href="https://github.com/talebook/talebook/blob/master/document/README.zh_CN.md#%E9%9D%99%E8%AF%BB%E5%A4%A9%E4%B8%8Bapp%E9%87%8C%E8%AE%BF%E9%97%AE%E4%B9%A6%E5%BA%93%E4%BC%9A%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E" target="_blank" rel="noopener">https://github.com/talebook/talebook/blob/master/document/README.zh_CN.md#%E9%9D%99%E8%AF%BB%E5%A4%A9%E4%B8%8Bapp%E9%87%8C%E8%AE%BF%E9%97%AE%E4%B9%A6%E5%BA%93%E4%BC%9A%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E</a></li></ul></blockquote><p><strong>Enjoy!</strong></p><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/docker-repo/tree/talebook" target="_blank" rel="noopener">https://github.com/JasonkayZK/docker-repo/tree/talebook</a></li></ul><p>参考：</p><ul><li><a href="https://www.bilibili.com/video/BV1AT411S7c3/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1AT411S7c3/</a></li><li><a href="https://blog.hsu.life/2024/01/14/%E6%89%8B%E6%9C%BA%E5%A6%82%E4%BD%95%E6%96%B9%E4%BE%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A6%E5%BA%93/index.html" target="_blank" rel="noopener">https://blog.hsu.life/2024/01/14/%E6%89%8B%E6%9C%BA%E5%A6%82%E4%BD%95%E6%96%B9%E4%BE%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A6%E5%BA%93/index.html</a></li><li><a href="https://gameapp.club/post/2022-12-25-ebooks/" target="_blank" rel="noopener">https://gameapp.club/post/2022-12-25-ebooks/</a></li></ul><br>]]></content>
    
    
    <summary type="html">我平时看的都是PDF电子书籍，但是之前没有用书籍管理，所以书籍比较乱；比较有名的书籍管理系统有Calibre，但是Talebook支持OPDS，同时能从豆瓣导入信息，比较好用；本文介绍了如何部署和配置Talebook；</summary>
    
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/categories/工具分享/"/>
    
    
    <category term="工具分享" scheme="https://jasonkayzk.github.io/tags/工具分享/"/>
    
    <category term="软件推荐" scheme="https://jasonkayzk.github.io/tags/软件推荐/"/>
    
  </entry>
  
  <entry>
    <title>2024年安装Docker的方法</title>
    <link href="https://jasonkayzk.github.io/2024/08/22/2024%E5%B9%B4%E5%AE%89%E8%A3%85Docker%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://jasonkayzk.github.io/2024/08/22/2024%E5%B9%B4%E5%AE%89%E8%A3%85Docker%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2024-08-22T02:00:43.000Z</published>
    <updated>2025-07-30T10:34:36.180Z</updated>
    
    <content type="html"><![CDATA[<p>阿里云的Docker源没了，本文写了在2024年如何安装Docker、配置DockerHub源；</p><p>PS：没想到2024年了，还在写Docker安装的教程…</p><br><a id="more"></a><h1 id="2024年安装Docker的方法"><a href="#2024年安装Docker的方法" class="headerlink" title="2024年安装Docker的方法"></a><strong>2024年安装Docker的方法</strong></h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a><strong>安装Docker</strong></h2><p>目前（2024年8月22日），阿里云已不再提供 Docker 源的安装（404了）；</p><p>腾讯云目前还是提供的，安装教程如下：</p><ul><li><a href="https://cloud.tencent.com/document/product/213/46000#C_XgAwZpjht292j2EOU2t" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/213/46000#C_XgAwZpjht292j2EOU2t</a></li></ul><p>Ubuntu的安装如下：</p><pre><code class="bash">sudo apt-get updatesudo apt-get install ca-certificates curlsudo install -m 0755 -d /etc/apt/keyrings# Debian系统将ubuntu改为debian！sudo curl -fsSL https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascsudo chmod a+r /etc/apt/keyrings/docker.asc# Debian系统将ubuntu改为debian！echo   &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/ \  $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; |   sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update</code></pre><blockquote><p>  <strong>需要注意的是：如果是Debian系统，需要将上面的ubuntu改为debian即可！</strong></p></blockquote><p>安装：</p><pre><code class="bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre><br><h2 id="Docker镜像源"><a href="#Docker镜像源" class="headerlink" title="Docker镜像源"></a><strong>Docker镜像源</strong></h2><p>众所周知，由于不可抗因素，国内是无法在 DockerHub 上 pull 镜像的，Github 的 <a href="https://ghcr.io/" target="_blank" rel="noopener"><strong>ghcr.io</strong></a> 也不行；</p><p>下面的网址提供了一些目前可用的镜像站：</p><ul><li><a href="https://taimatsu.xlog.app/china-mirror-proxy?locale=zh" target="_blank" rel="noopener">https://taimatsu.xlog.app/china-mirror-proxy?locale=zh</a></li><li><a href="https://qinyang.wang/china-mirror-proxy" target="_blank" rel="noopener">https://qinyang.wang/china-mirror-proxy</a></li><li><a href="https://github.com/cmliu/CF-Workers-docker.io" target="_blank" rel="noopener">https://github.com/cmliu/CF-Workers-docker.io</a></li></ul><p>以及使用 CF 搭建镜像站的教程：</p><ul><li><a href="https://www.lincol29.cn/cloudflaretodocker" target="_blank" rel="noopener">https://www.lincol29.cn/cloudflaretodocker</a></li><li><a href="https://github.com/cmliu/CF-Workers-docker.io" target="_blank" rel="noopener">https://github.com/cmliu/CF-Workers-docker.io</a></li></ul><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>参考：</p><ul><li><a href="https://cloud.tencent.com/document/product/213/46000#C_XgAwZpjht292j2EOU2t" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/213/46000#C_XgAwZpjht292j2EOU2t</a></li></ul><br>]]></content>
    
    
    <summary type="html">阿里云的Docker源没了，本文写了在2024年如何安装Docker、配置DockerHub源；PS：没想到2024年了，还在写Docker安装的教程...</summary>
    
    
    
    <category term="软件安装与配置" scheme="https://jasonkayzk.github.io/categories/软件安装与配置/"/>
    
    
    <category term="软件安装与配置" scheme="https://jasonkayzk.github.io/tags/软件安装与配置/"/>
    
    <category term="Docker" scheme="https://jasonkayzk.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Python项目Linter、Formatter和Github-Actions配置</title>
    <link href="https://jasonkayzk.github.io/2024/08/21/Python%E9%A1%B9%E7%9B%AELinter%E3%80%81Formatter%E5%92%8CGithub-Actions%E9%85%8D%E7%BD%AE/"/>
    <id>https://jasonkayzk.github.io/2024/08/21/Python%E9%A1%B9%E7%9B%AELinter%E3%80%81Formatter%E5%92%8CGithub-Actions%E9%85%8D%E7%BD%AE/</id>
    <published>2024-08-21T07:26:53.000Z</published>
    <updated>2025-07-30T10:34:36.198Z</updated>
    
    <content type="html"><![CDATA[<p>关于Python项目的一些配置问题，包括：</p><ul><li>Linter</li><li>Formatter</li><li>Github-Actions配置；</li></ul><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/python-learn" target="_blank" rel="noopener">https://github.com/JasonkayZK/python-learn</a></li></ul><br><a id="more"></a><h1 id="Python项目Linter、Formatter和Github-Actions配置"><a href="#Python项目Linter、Formatter和Github-Actions配置" class="headerlink" title="Python项目Linter、Formatter和Github-Actions配置"></a><strong>Python项目Linter、Formatter和Github-Actions配置</strong></h1><h2 id="Linter"><a href="#Linter" class="headerlink" title="Linter"></a><strong>Linter</strong></h2><p>Linter 使用的是 PyCharm 自带的，符合 PEP8 规范；</p><p>也可以使用：</p><ul><li>flake8</li><li>pylint</li></ul><br><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a><strong>Formatter</strong></h2><p>直接用  isort 和 black 就可以了：</p><ul><li><a href="https://github.com/psf/black" target="_blank" rel="noopener">https://github.com/psf/black</a></li><li><a href="https://github.com/pycqa/isort" target="_blank" rel="noopener">https://github.com/pycqa/isort</a></li></ul><br><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a><strong>项目配置</strong></h2><p>Pre-Commit：</p><p>.pre-commit-config.yaml</p><pre><code class="yaml">repos:  - repo: https://github.com/psf/black    rev: 23.1.0    hooks:      - id: black  - repo: https://github.com/pycqa/isort    rev: 5.12.0    hooks:      - id: isort</code></pre><br><p>PyProject：</p><p>pyproject.toml</p><pre><code class="toml">[tool.isort]profile = &quot;black&quot;</code></pre><br><p>依赖配置：</p><p>requirements.txt</p><pre><code class="text">-e .[all]...</code></pre><p>requirements-dev.txt</p><pre><code class="text">-r requirements.txt# Ciblackisort</code></pre><br><p>Github Actions:</p><p>.github/workflows/ci.yaml</p><pre><code class="yaml">name: CIon:  workflow_dispatch:  push:  pull_request:jobs:  lint_and_test:    runs-on: ubuntu-latest    strategy:      max-parallel: 4      matrix:        python-version: [&#39;3.10&#39;, &#39;3.11&#39;, &#39;3.12&#39;]    steps:      - uses: actions/checkout@v4      - name: Set up Python ${{ matrix.python-version }}        id: setup_python        uses: actions/setup-python@v5        with:          python-version: ${{ matrix.python-version }}          cache: &#39;pip&#39;          cache-dependency-path: &#39;requirements-dev.txt&#39;      - name: Install dependencies        run: |          pip install -r requirements-dev.txt      - name: Run lint        uses: pre-commit/action@v2.0.0</code></pre><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>源代码：</p><ul><li><a href="https://github.com/JasonkayZK/python-learn" target="_blank" rel="noopener">https://github.com/JasonkayZK/python-learn</a></li></ul><p>参考：</p><ul><li><a href="https://v2ex.com/t/587696" target="_blank" rel="noopener">https://v2ex.com/t/587696</a></li><li><a href="https://github.com/psf/black" target="_blank" rel="noopener">https://github.com/psf/black</a></li><li><a href="https://github.com/pycqa/isort" target="_blank" rel="noopener">https://github.com/pycqa/isort</a></li></ul><br>]]></content>
    
    
    <summary type="html">关于Python项目的一些配置问题，包括：Linter、Formatter和Github-Actions配置；</summary>
    
    
    
    <category term="技术杂谈" scheme="https://jasonkayzk.github.io/categories/技术杂谈/"/>
    
    
    <category term="技术杂谈" scheme="https://jasonkayzk.github.io/tags/技术杂谈/"/>
    
  </entry>
  
  <entry>
    <title>Zerotier配置内网流量转发</title>
    <link href="https://jasonkayzk.github.io/2024/08/21/Zerotier%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/"/>
    <id>https://jasonkayzk.github.io/2024/08/21/Zerotier%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/</id>
    <published>2024-08-21T01:51:01.000Z</published>
    <updated>2025-07-30T10:34:36.203Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="/2024/07/28/%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%BB%84%E7%BD%91%E5%B7%A5%E5%85%B7ZeroTier/">《简单易用的内网穿透组网工具ZeroTier》</a>中，简单介绍了组网工具Zerotier；</p><p>实际上，我们可以通过Ip Forward的方式来访问组网设备内网下的其他设备！</p><br><a id="more"></a><h1 id="Zerotier配置内网流量转发"><a href="#Zerotier配置内网流量转发" class="headerlink" title="Zerotier配置内网流量转发"></a><strong>Zerotier配置内网流量转发</strong></h1><p>首先，在这台机器上配置 IP 转发：</p><pre><code class="shell">sudo sysctl -w net.ipv4.ip_forward=1sudo sysctl -p</code></pre><p>查看网卡配置：</p><pre><code class="bash">ip aens33: 192.168.117.0/24ztnfanm5kw: 192.168.196.220</code></pre><p>在zerotier网站设置转发规则：</p><p><img src="https://raw.gitmirror.com/JasonkayZK/blog_static/master/images/zerotier.jpg" alt="alipay"></p><p>在这台流量转发机器上设置环境变量：</p><pre><code class="bash">export PHY_IFACE=ens33 # 物理网卡export ZT_IFACE=ztnfanm5kw # Zerotier虚拟网卡</code></pre><p>添加规则到iptables：</p><pre><code class="bash">sudo iptables -t nat -A POSTROUTING -o $PHY_IFACE -j MASQUERADEsudo iptables -A FORWARD -i $PHY_IFACE -o $ZT_IFACE -m state --state RELATED,ESTABLISHED -j ACCEPTsudo iptables -A FORWARD -i $ZT_IFACE -o $PHY_IFACE -j ACCEPT</code></pre><blockquote><p>  这三条 <code>iptables</code> 规则用于配置网络地址转换（NAT）和数据包转发；</p><p>  含义如下：</p><ol><li><p><strong>规则 1：</strong> <code>sudo iptables -t nat -A POSTROUTING -o $PHY_IFACE -j MASQUERADE</code></p><p>这条规则在 <code>nat</code> 表的 <code>POSTROUTING</code> 链中添加了一条规则。<code>-o $PHY_IFACE</code> 表示这条规则适用于所有通过 <code>$PHY_IFACE</code> 这个网络接口（通常是物理接口）出去的数据包。<code>-j MASQUERADE</code> 指定了 NAT 操作中的伪装（masquerading）。这意味着，当数据包从 <code>$PHY_IFACE</code> 发送出去时，其源 IP 地址会被替换为 <code>$PHY_IFACE</code> 的 IP 地址。这通常用于允许内部网络通过一个公共 IP 地址进行外部通信；</p></li><li><p><strong>规则 2：</strong> <code>sudo iptables -A FORWARD -i $PHY_IFACE -o $ZT_IFACE -m state --state RELATED,ESTABLISHED -j ACCEPT</code></p><p>这条规则在 <code>filter</code> 表的 <code>FORWARD</code> 链中添加了一条规则。<code>-i $PHY_IFACE</code> 表示适用于从 <code>$PHY_IFACE</code> 这个接口进入的数据包，<code>-o $ZT_IFACE</code> 表示这些数据包要转发到 <code>$ZT_IFACE</code> 这个接口。<code>-m state --state RELATED,ESTABLISHED</code> 指定了只有那些与已有连接相关或已经建立的连接的数据包才被接受（<code>ACCEPT</code>）。这个规则通常用于允许来自外部网络的返回流量进入内部网络，从而支持诸如 HTTP 会话等；</p></li><li><p><strong>规则 3：</strong> <code>sudo iptables -A FORWARD -i $ZT_IFACE -o $PHY_IFACE -j ACCEPT</code></p><p>这条规则在 <code>filter</code> 表的 <code>FORWARD</code> 链中添加了一条规则。<code>-i $ZT_IFACE</code> 表示适用于从 <code>$ZT_IFACE</code> 这个接口进入的数据包，<code>-o $PHY_IFACE</code> 表示这些数据包要转发到 <code>$PHY_IFACE</code> 这个接口。<code>-j ACCEPT</code> 表示这些数据包会被接受并转发。这条规则允许来自 <code>$ZT_IFACE</code> 的流量经过路由器转发到 <code>$PHY_IFACE</code>，从而实现网络之间的数据传输；</p><p>总结：</p></li></ol><ul><li>第一条规则用于设置源地址伪装，允许内部网络设备通过一个公共 IP 地址进行外部通信；</li><li>第二条规则允许返回流量和已经建立的连接的数据包从外部网络进入内部网络；</li><li>第三条规则允许来自内部网络的数据包被转发到外部网络；</li></ul></blockquote><p>保存配置到文件：</p><pre><code class="bash">iptables-save</code></pre><p><strong>此时就可以用另一台加入了此Zerotier网络的机器访问内网机器的其他电脑了！</strong></p><br><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h1><p>文章参考：</p><ul><li><a href="https://blog.51cto.com/u_6364219/5264985" target="_blank" rel="noopener">https://blog.51cto.com/u_6364219/5264985</a></li></ul><br>]]></content>
    
    
    <summary type="html">在上一篇文章《简单易用的内网穿透组网工具ZeroTier》中，简单介绍了组网工具Zerotier；实际上，我们可以通过Ip Forward的方式来访问组网设备内网下的其他设备！</summary>
    
    
    
    <category term="技术杂谈" scheme="https://jasonkayzk.github.io/categories/技术杂谈/"/>
    
    
    <category term="技术杂谈" scheme="https://jasonkayzk.github.io/tags/技术杂谈/"/>
    
  </entry>
  
  <entry>
    <title>关于说话艺术的资源</title>
    <link href="https://jasonkayzk.github.io/2024/08/21/%E5%85%B3%E4%BA%8E%E8%AF%B4%E8%AF%9D%E8%89%BA%E6%9C%AF%E7%9A%84%E8%B5%84%E6%BA%90/"/>
    <id>https://jasonkayzk.github.io/2024/08/21/%E5%85%B3%E4%BA%8E%E8%AF%B4%E8%AF%9D%E8%89%BA%E6%9C%AF%E7%9A%84%E8%B5%84%E6%BA%90/</id>
    <published>2024-08-21T01:14:31.000Z</published>
    <updated>2025-07-30T10:34:36.214Z</updated>
    
    <content type="html"><![CDATA[<p>一些锻炼口才、学习讲话的资源</p><br><a id="more"></a><h1 id="关于语言艺术的资源"><a href="#关于语言艺术的资源" class="headerlink" title="关于语言艺术的资源"></a><strong>关于语言艺术的资源</strong></h1><p>资源：</p><ul><li><a href="https://www.bilibili.com/video/BV1Wg4y1N7qW/" target="_blank" rel="noopener">《南开大学《口才艺术与社交礼仪》艾跃进 57集全》</a></li><li><a href="https://www.bilibili.com/video/BV1Ys411e7tZ/" target="_blank" rel="noopener">《【张雪峰】口才是如何炼成的？》</a></li><li><a href="https://www.bilibili.com/video/BV1kb4y1X7b7/" target="_blank" rel="noopener">《【艾跃进】怎么在平时练习口才和情商，必看的口才练习建议》</a></li><li><a href="https://www.bilibili.com/video/BV1qw4m1e7CC/" target="_blank" rel="noopener">《如何提高演讲口才能力？张雪峰一言以蔽之》</a></li><li><a href="https://www.ahhhhfs.com/?cat=&amp;s=%E5%8F%A3%E6%89%8D" target="_blank" rel="noopener">https://www.ahhhhfs.com/?cat=&amp;s=%E5%8F%A3%E6%89%8D</a></li></ul><br>]]></content>
    
    
    <summary type="html">一些锻炼口才、学习讲话的资源</summary>
    
    
    
    <category term="人生日记" scheme="https://jasonkayzk.github.io/categories/人生日记/"/>
    
    
    <category term="口才" scheme="https://jasonkayzk.github.io/tags/口才/"/>
    
  </entry>
  
</feed>
