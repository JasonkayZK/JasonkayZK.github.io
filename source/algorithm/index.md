---

title: Algorithm
date: 2020-03-22 10:23:17
layout: about
cover: http://api.mtyqx.cn/api/random.php?2
---

*「人生とかホントはいきなり事じゃない」* ———— 2020.03.21悟

<br/>

## 算法总结

**本页面创立于: 2020年03月22日**

**页面成立原因: 解决个人算法较差的痛点**

**Github:** 

-   **算法基础：**https://github.com/JasonkayZK/Java_Algorithm
-   **LeetCode：**https://github.com/JasonkayZK/LeetCode_Java

**其他:**

为了不影响其他文章的阅读，算法文章统一日期1996-07-27

算法可以说一直以来是本人的一个痛点，以下文章可能总结的并不是很好，希望大家能多批评，并提出宝贵意见～

**目录**

<!-- toc -->

<br/>

## 算法分类

### 数学

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [数值的整数次方](https://jasonkayzk.github.io/1996/07/27/算法-数值的整数次方/) |  2020-03-31  |     ☆      |    ☆☆☆☆    | 简单的快速幂                                                 |
| [数组中出现次数超过一半的数字](https://jasonkayzk.github.io/1996/07/27/算法-数组中出现次数超过一半的数字/) |  2020-04-01  |     ☆☆     |    ☆☆☆     | 使用[摩尔投票法](https://blog.csdn.net/happyeveryday62/article/details/104136295)<br />**[求众数]** |
| [整数中1出现的次数](https://jasonkayzk.github.io/1996/07/27/算法-整数中1出现的次数/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 归纳总结规律                                                 |
| [第N个丑数](https://jasonkayzk.github.io/1996/07/27/算法-第N个丑数/) |  2020-04-01  |    ☆☆☆     |    ☆☆☆☆    | 维护2,3,5的乘积队列                                          |
|                                                              |              |            |            |                                                              |
|                                                              |              |            |            |                                                              |



****

### 位运算

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**               |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :--------------------- |
| [二进制中1的个数](https://jasonkayzk.github.io/1996/07/27/算法-二进制中1的个数/) |  2020-03-31  |     ☆      |    ☆☆☆     | 计算一个数的二进制表示 |
|                                                              |              |            |            |                        |





****

### 动态规划

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [跳台阶](https://jasonkayzk.github.io/1996/07/27/算法-跳台阶/) |  2020-03-31  |     ☆☆     |     ☆☆     | 简单的一维动态规划(斐波那契)                                 |
| [变态跳台阶](https://jasonkayzk.github.io/1996/07/27/算法-变态跳台阶/) |  2020-03-31  |     ☆☆     |     ☆☆     | 简单的一维动态规划                                           |
| [连续子数组的最大和](https://jasonkayzk.github.io/1996/07/27/算法-连续子数组的最大和/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 简单的动态规划<br />其中dp[i]表示从a[0]~a[i]的连续子数组的最大值 |
|                                                              |              |            |            |                                                              |





****

### 堆

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                               |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------- |
| [最小的K个数](https://jasonkayzk.github.io/1996/07/27/算法-最小的K个数/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 求最小的K个数使用最大堆;<br />求最大的K个数使用最小堆; |
|                                                              |              |            |            |                                                        |
|                                                              |              |            |            |                                                        |







****

### 二叉树

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [重建二叉树](https://jasonkayzk.github.io/1996/07/27/算法-重建二叉树/) |  2020-03-31  |     ☆☆     |   ☆☆☆☆☆    | 利用二叉树前序和中序遍历的特点<br />通过分治重建二叉树       |
| [树的子结构](https://jasonkayzk.github.io/1996/07/27/算法-树的子结构/) |  2020-03-31  |     ☆☆     |    ☆☆☆     | 通过递归进行判断:<br />如果A当前节点等于B的根节点, 递归判断是否是子树 |
| [二叉树的镜像](https://jasonkayzk.github.io/1996/07/27/算法-二叉树的镜像/) |  2020-03-31  |     ☆☆     |    ☆☆☆     | 通过先序遍历, 递归的将root的左子树和右子树交换即可           |
| [从上往下打印二叉树](https://jasonkayzk.github.io/1996/07/27/算法-从上往下打印二叉树/) |  2020-03-31  |     ☆☆     |    ☆☆☆☆    | 简单的二叉树的BFS                                            |
| [二叉搜索树的后序遍历序列](https://jasonkayzk.github.io/1996/07/27/算法-二叉搜索树的后序遍历序列/) |  2020-04-01  |     ☆☆     |    ☆☆☆     | 对于二叉树的子树进行递归<br />拆分左右子树, 判断条件         |
| [二叉树中和为某一值的路径](https://jasonkayzk.github.io/1996/07/27/算法-二叉树中和为某一值的路径/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 典型的回溯法<br />每一步结束则对当前节点进行回溯返回         |
| [二叉搜索树与双向链表](https://jasonkayzk.github.io/1996/07/27/算法-二叉搜索树与双向链表/) |  2020-04-01  |     ☆☆     |    ☆☆☆     | 对于BST的中序遍历就是有序的<br />针对双向链表的操作可以参考类似于链表翻转 |
| [二叉树的深度](https://jasonkayzk.github.io/1996/07/27/算法-二叉树的深度/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 递归:<br />root.height = max(height(root.left), height(root.right)) + 1 |
| [平衡二叉树](https://jasonkayzk.github.io/1996/07/27/算法-平衡二叉树/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 从下往上遍历<br />如果子树是平衡二叉树，则返回子树的高度；<br />如果子树不是平衡二叉树，则直接停止遍历 |
|                                                              |              |            |            |                                                              |
|                                                              |              |            |            |                                                              |





****

### 树

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |







****

### 查找

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [二维数组中的查找](https://jasonkayzk.github.io/1996/07/27/算法-二维数组中的查找/) |  2020-03-31  |     ☆☆     |     ☆☆     | 利用数组有序的特性进行优化                                   |
| [旋转数组的最小数字](https://jasonkayzk.github.io/1996/07/27/算法-旋转数组的最小数字/) |  2020-03-31  |     ☆☆     |    ☆☆☆     | 利用单边的二分法进行查找<br />关键在于分清不同的情况         |
| [数字在排序数组中出现的次数](https://jasonkayzk.github.io/1996/07/27/算法-数字在排序数组中出现的次数/) |  2020-04-01  |     ☆☆     |     ☆☆     | 先通过二分找到其中出现的任意一个的索引<br />然后计算这个这个索引左右两侧的个数即可 |
|                                                              |              |            |            |                                                              |
|                                                              |              |            |            |                                                              |





****

### 双指针

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                          |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :-------------------------------- |
| [链表中倒数第k个结点](https://jasonkayzk.github.io/1996/07/27/算法-链表中倒数第k个结点/) |  2020-03-31  |     ☆☆     |    ☆☆☆☆    | 使用快慢指针<br />让快指针先走k步 |
|                                                              |              |            |            |                                   |
|                                                              |              |            |            |                                   |







****

### 递归

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                       |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------- |
| [矩形覆盖](https://jasonkayzk.github.io/1996/07/27/算法-矩形覆盖/) |  2020-03-31  |    ☆☆☆     |    ☆☆☆     | 利用找规律的方法, 进行递归处理 |
|                                                              |              |            |            |                                |







****

### 分治

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |



****

### 回溯

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                               |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------- |
| [二叉树中和为某一值的路径](https://jasonkayzk.github.io/1996/07/27/算法-二叉树中和为某一值的路径/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 典型的回溯法<br />每一步结束则对当前节点进行回溯返回   |
| [字符串的排列](https://jasonkayzk.github.io/1996/07/27/算法-字符串的排列/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 使用回溯法<br />通过交换字符串对应的位置进行字符串构建 |
|                                                              |              |            |            |                                                        |





****

### 划窗

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |







****

### 哈希表

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |





****

### 矩阵

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |





****

### BFS

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**          |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :---------------- |
| [从上往下打印二叉树](https://jasonkayzk.github.io/1996/07/27/算法-从上往下打印二叉树/) |  2020-03-31  |     ☆☆     |    ☆☆☆☆    | 简单的二叉树的BFS |
|                                                              |              |            |            |                   |





****

### DFS

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |





****

### 链表

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [从尾到头打印链表](https://jasonkayzk.github.io/1996/07/27/算法-从尾到头打印链表/) |  2020-03-31  |     ☆☆     |   ☆☆☆☆☆    | 建立pre, cur两个指针<br />使用cur拆分链表, pre记录前一链表   |
| [链表中倒数第k个结点](https://jasonkayzk.github.io/1996/07/27/算法-链表中倒数第k个结点/) |  2020-03-31  |     ☆☆     |    ☆☆☆☆    | 使用快慢指针<br />让快指针先走k步                            |
| [合并两个排序的链表](https://jasonkayzk.github.io/1996/07/27/算法-合并两个排序的链表/) |  2020-03-31  |     ☆☆     |    ☆☆☆☆    | 类似于归并排序中归并的操作                                   |
| [复杂链表的复制](https://jasonkayzk.github.io/1996/07/27/算法-复杂链表的复制/) |  2020-04-01  |     ☆☆     |     ☆☆     | 遍历两次.<br />使用HashMap保存节点                           |
| [二叉搜索树与双向链表](https://jasonkayzk.github.io/1996/07/27/算法-二叉搜索树与双向链表/) |  2020-04-01  |     ☆☆     |    ☆☆☆     | 对于BST的中序遍历就是有序的<br />针对双向链表的操作可以参考类似于链表翻转 |
| [两个链表的第一个公共结点](https://jasonkayzk.github.io/1996/07/27/算法-两个链表的第一个公共结点/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 设定两个指针分别从list1和list2开始.<br />list1当到达链表1结尾时, 继续从链表2开始;<br />list2同理; |
|                                                              |              |            |            |                                                              |
|                                                              |              |            |            |                                                              |





****

### 图

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |





****

### 并查集

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |







****

### 排序

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                   |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------- |
| [调整数组顺序使奇数位于偶数前面](https://jasonkayzk.github.io/1996/07/27/算法-调整数组顺序使奇数位于偶数前面/) |  2020-03-31  |     ☆☆     |     ☆☆     | 类似于稳定的排序                           |
| [合并两个排序的链表](https://jasonkayzk.github.io/1996/07/27/算法-合并两个排序的链表/) |  2020-03-31  |     ☆☆     |    ☆☆☆☆    | 类似于归并排序中归并的操作                 |
| [把数组排成最小的数](https://jasonkayzk.github.io/1996/07/27/算法-把数组排成最小的数/) |  2020-04-01  |     ☆☆     |    ☆☆☆     | 按照{arr[i], arr[j]}组合较小的方式进行排序 |
|                                                              |              |            |            |                                            |
|                                                              |              |            |            |                                            |





****

### 数组

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [二维数组中的查找](https://jasonkayzk.github.io/1996/07/27/算法-二维数组中的查找/) |  2020-03-31  |     ☆☆     |     ☆☆     | 利用数组有序的特性进行优化                                   |
| [调整数组顺序使奇数位于偶数前面](https://jasonkayzk.github.io/1996/07/27/算法-调整数组顺序使奇数位于偶数前面/) |  2020-03-31  |     ☆☆     |     ☆☆     | 类似于稳定的排序                                             |
| [顺时针打印矩阵](https://jasonkayzk.github.io/1996/07/27/算法-顺时针打印矩阵/) |  2020-03-31  |     ☆      |     ☆☆     | 分四个方向遍历即可                                           |
| [数组中出现次数超过一半的数字](https://jasonkayzk.github.io/1996/07/27/算法-数组中出现次数超过一半的数字/) |  2020-04-01  |     ☆☆     |    ☆☆☆     | 使用[摩尔投票法](https://blog.csdn.net/happyeveryday62/article/details/104136295)<br />**[求众数]** |
| [最小的K个数](https://jasonkayzk.github.io/1996/07/27/算法-最小的K个数/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 求最小的K个数使用最大堆;<br />求最大的K个数使用最小堆;       |
| [连续子数组的最大和](https://jasonkayzk.github.io/1996/07/27/算法-连续子数组的最大和/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 简单的动态规划<br />其中dp[i]表示从a[0]~a[i]的连续子数组的最大值 |
|                                                              |              |            |            |                                                              |
|                                                              |              |            |            |                                                              |





****

### 贪心

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |





****

### 线段树

| **题目** | **添加时间** | **难易度** | **重要度** | **备注** |
| :------: | :----------: | :--------: | :--------: | :------- |
|          |              |            |            |          |
|          |              |            |            |          |



****

### 栈

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [用两个栈实现队列](https://jasonkayzk.github.io/1996/07/27/算法-用两个栈实现队列/) |  2020-03-31  |     ☆☆     |     ☆☆     | 两个栈<br />一个用来存放入栈的数据, 一个用来存放出栈的数据   |
| [包含min函数的栈](https://jasonkayzk.github.io/1996/07/27/算法-包含min函数的栈/) |  2020-03-31  |     ☆☆     |    ☆☆☆     | 设定两个栈stack和minStack<br />针对不同的操作保持minStack.peak为最小 |
| [栈的压入、弹出序列](https://jasonkayzk.github.io/1996/07/27/算法-栈的压入、弹出序列/) |  2020-03-31  |     ☆☆     |    ☆☆☆     | 通过一个Stack模拟操作即可                                    |
|                                                              |              |            |            |                                                              |



****

### 队列

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                   |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :--------------------------------------------------------- |
| [用两个栈实现队列](https://jasonkayzk.github.io/1996/07/27/算法-用两个栈实现队列/) |  2020-03-31  |     ☆☆     |    ☆☆☆     | 两个栈<br />一个用来存放入栈的数据, 一个用来存放出栈的数据 |
|                                                              |              |            |            |                                                            |

****

### 字符串

|                           **题目**                           | **添加时间** | **难易度** | **重要度** | **备注**                                                     |
| :----------------------------------------------------------: | :----------: | :--------: | :--------: | :----------------------------------------------------------- |
| [替换空格](https://jasonkayzk.github.io/1996/07/27/算法-替换空格/) |  2020-03-31  |     ☆      |     ☆      |                                                              |
| [字符串的排列](https://jasonkayzk.github.io/1996/07/27/算法-字符串的排列/) |  2020-04-01  |     ☆☆     |    ☆☆☆☆    | 使用回溯法<br />通过交换字符串对应的位置进行字符串构建       |
| [第一个只出现一次的字符位置](https://jasonkayzk.github.io/1996/07/27/算法-第一个只出现一次的字符位置/) |  2020-04-01  |     ☆      |     ☆      | 第一遍遍历, 记录每个字符出现的次数;<br />第二次遍历, 寻找第一个出现一次的; |
| [数组中的逆序对](https://jasonkayzk.github.io/1996/07/27/算法-数组中的逆序对/) |  2020-04-01  |    ☆☆☆     |   ☆☆☆☆☆    | 本质上**逆序就是在归并排序的归并过程中产生的数字位置提升的总和数**<br />对数组进行归并排序 |
|                                                              |              |            |            |                                                              |

<br/>

## 请我喝Java

如果觉得博主的项目内容对你有帮助, 可以对本博主打赏哦!

**Alipay:**

![alipay](https://raw.githubusercontent.com/JasonkayZK/blog_static/master/images/alipay.jpg)

**WechatPay:**

![wechat](https://raw.githubusercontent.com/JasonkayZK/blog_static/master/images/wechat.jpg)

<br/>

------------------------------

如对以上项目内容有任何疑问, 欢迎与我交流:

**微信公众号: Coder张小凯**

**wechat: z271226192(优先)**

**qq: 271226192**

<br/>