---
title: 浅谈函数调用
toc: true
cover: 'https://img.paulzzh.tech/touhou/random?88'
date: 2022-06-01 21:16:20
categories: C++
tags: [C++, 技术杂谈]
description: 在任意一门编程语言中，函数调用基本上都是非常常见的操作；我们都知道，函数是由调用栈实现的，不同的函数调用会切换上下文；但是，你是否好奇，对于一个函数调用而言，其底层到底是如何实现的呢？本文讲解了函数调用的底层逻辑实现；
---

在任意一门编程语言中，函数调用基本上都是非常常见的操作；

我们都知道，函数是由调用栈实现的，不同的函数调用会切换上下文；

但是，你是否好奇，对于一个函数调用而言，其底层到底是如何实现的呢？

本文讲解了函数调用的底层逻辑实现；

<br/>

<!--more-->

# **浅谈函数调用**

## **汇编概述**

既然要讲解函数调用的底层逻辑实现，那么汇编语言我们是绕不过的；

因此，首先来复习一下汇编相关的知识；

我们都知道，计算机只能读懂二进制指令，而汇编就是一组特定的字符，汇编的每一条语句都直接对应 CPU 的二进制指令，比如：`mov rax, rdx` 就是我们常见的汇编指令；

汇编语言就是通过一条条的 助记符 + 操作数 实现的，并且汇编指令经过汇编器（assemble，例如 Linux 下的 `as`）转变为实际的 CPU 二进制指令；

<br/>

### **一个简单的汇编例子**

上面讲的有些空洞，来看一个实际的例子：

```assembly
; 将寄存器rsp的值存储到寄存器rbp中
mov rbp, rsp

; 将四个字节的4存储到地址为rbp-4的栈上
mov DWORD PTR [rbp-4], 4

; 将rsp的值减去16
sub rsp, 16
```

<red>**需要注意的是：汇编语言是和实际底层的 CPU 息息相关的；上面的汇编格式使用的便是 Intel 的语法格式；**</font>

**常见的汇编语言有两种截然不同的语法：**

-   **Intel 格式；**
-   **AT&T 格式；**

<red>**Intel 的格式是：`optcode destination, source`，类似于语法 int i = 4；**</font>

<red>**而 AT&T 的格式是：`optcode source, destination`，直观理解为 move from source to destination；**</font>

若将上面的 Intel 汇编改写为 AT&T 汇编，则为：

```assembly
movq %rsp, %rbp

movl $4, -4(%rbp)

subq $16, %rsp
```

可以看到，AT&T 汇编的另外一个特点是：**有前缀和后缀**；

**比如：前缀`%,$`；后缀 `q,l`等等；**

这些前缀后缀有特殊的意思，后文会讲解，不同的格式侧重点不太一样；

<br/>

### **通用寄存器概述**

对于汇编语言，仅仅了解其语法内容是远远不够的！

由于汇编语言和 CPU 是息息相关的，因此在硬件层面我们还需要关注 CPU 的通用寄存器；

<red>**在所有 CPU 体系架构中，每个寄存器通常都是有建议的使用方法的，而编译器也通常依照 CPU 架构的建议来使用这些寄存器，因而我们可以认为这些建议是强制性的；**</font>

对于 x86-64 架构，最常用的有 16 个64位通用寄存器，各寄存器及用途如下所示：

| **寄存器**  | **被调用者保存（Caller Save）** | **简述** |
| ----------- | ------------------------------- | -------- |
| **rax**     |                                 |          |
| **rbx**     | YES                             |          |
| **rcx**     |                                 |          |
| **rdx**     |                                 |          |
| **rsp**     |                                 |          |
| **rbp**     | YES                             |          |
| **rsi**     |                                 |          |
| **rdi**     |                                 |          |
| **r8**      |                                 |          |
| **r9**      |                                 |          |
| **r10**     |                                 |          |
| **r11**     |                                 |          |
| **r12~r15** | YES                             |          |

















<br/>

# **附录**

文章参考：

-   [《程序是怎样跑起来的》](https://book.douban.com/subject/26365491/)
-   [《程序员的自我修养 : 链接、装载与库》](https://book.douban.com/subject/3652388/)
-   https://zhuanlan.zhihu.com/p/368962727
-   https://zhuanlan.zhihu.com/p/27339191


<br/>
