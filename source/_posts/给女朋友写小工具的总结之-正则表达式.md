---
title: 给女朋友写小工具的总结之-正则表达式
toc: false
date: 2019-09-08 19:09:54
categories: 正则表达式
tags: [正则表达式, 字符串处理, Python]
description: 今天给女朋友写的一个提取几个文件的数据的python小工具总结.
---

![avatar](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567951431117&di=69d0d275e608b59cc641c5e5f1051cac&imgtype=0&src=http%3A%2F%2Fimg4.mukewang.com%2F5b38507d0001942e06800385.jpg)		

</br>女朋友最近要用到电力系统分析相关的一些数据, 但是用到的BPA软件生成的文件有好几个, 八万多行的文件都有. 每次处理起来都是自己手动输入, 很是麻烦. 我今天一看, 不就是基本的文件I/O加上正则表达嘛, 这又什么难得, Python走起!

<!--more-->

### 一. 需求分析

多个类似于:

```
# File name: 33bpa.lis

Wall clock : Sun Sep 08 09:52:36 2019

<MULTI_NODE_EQUAL_RESULT>
.#      ???             ??????            ??????           ??????             ??????
.#                     G0+jB0(p.u.)        G1+jB1(p.u.)        G2+jB2(p.u.)       Im(kA)  Ia(deg)
.#----------------  ------------------  ------------------  ------------------  ------------------
B "BUS-30  " 100.0    0.0000    0.0000    3.4355  -51.9441    3.2023  -52.7944   30.0554  -86.2160
B "BUS-31  " 100.0    0.0000    0.0000    3.9110  -30.8303    3.5087  -33.5190   17.9425  -82.7702
B "BUS-32  " 100.0    0.0000    0.0000    3.6146  -36.5561    3.2913  -38.7305   21.2086  -84.3531
........................
```

```
SWING CASE: 39测试     POWERFLOW CASE: 039bpa             * * *  输 出 信 息  * * *                            Date: 2019-09-06

 * 发电机"BUS-30   100.0 "输出数据列表
 
     功角        (度)              最大值 =   -51.3867/   74.0          最小值 =   -51.3869/  186.0          参考发电机    BUS-31   100.0  
     0.0  -51.3868       0.0  -51.3868       1.0  -51.3868       2.0  -51.3868       3.0  -51.3868       4.0  -51.3867       5.0  -51.3867       6.0  -51.3867
     7.0  -51.3867       8.0  -51.3867       9.0  -51.3867      10.0  -51.3867      11.0  -51.3868      12.0  -51.3868      13.0  -51.3868      14.0  -51.3868
    15.0  -51.3868      16.0  -51.3868      17.0  -51.3868      18.0  -51.3868      19.0  -51.3868      20.0  -51.3868      21.0  -51.3868      22.0  -51.3868
    23.0  -51.3868      24.0  -51.3868      25.0  -51.3868      26.0  -51.3868      27.0  -51.3868      28.0  -51.3868      29.0  -51.3868      30.0  -51.3868
    31.0  -51.3868      32.0  -51.3868      33.0  -51.3868      34.0  -51.3868      35.0  -51.3868      36.0  -51.3868      37.0  -51.3868      38.0  -51.3868
    39.0  -51.3868      40.0  -51.3868      41.0  -51.3868      42.0  -51.3868      43.0  -51.3868      44.0  -51.3868      45.0  -51.3868      46.0  -51.3868
    47.0  -51.3868      48.0  -51.3868      49.0  -51.3868      50.0  -51.3868      51.0  -51.3868      52.0  -51.3868      53.0  -51.3868      54.0  -51.3868
    55.0  -51.3868      56.0  -51.3868      57.0  -51.3868      58.0  -51.3868      59.0  -51.3868      60.0  -51.3868      61.0  -51.3868      62.0  -51.3868
    ......................
```

这样的文件中提取某些参数, 并构建对应的矩阵, 包括对称矩阵等.

### 二. 实现分析

#### 1. 构建配置文件:

首先创建config.json配置文件, 今后从此文件中读取配置, 而不用在源码上进行修改!

``` json
{
    "data_folder": "E:\\BPA_generator",
    "out_file": "ieee90.OUT",
    "swi_file": "IEEE90.SWI",
    "lis_file": "ieee90.lis",

    "motor_number": [1,2,3],
    "fault_time": 1,
    
    "save_to": ".\\generate.txt"
}
```

在python中读取配置:

```python
# 读入配置文件
with open("config.json") as f:
    config = json.load(f)
    data_folder = config["data_folder"]
    out_file = config["out_file"]
    swi_file = config["swi_file"]
    lis_file = config["lis_file"]

    motor_number = config["motor_number"]
    fault_time = float(config["fault_time"])

    motor_dict = dict()
    for i in range(len(motor_number)):
        motor_dict[motor_number[i]] = i

    save_to = config["save_to"]
```

其中motor_dict用于构建将给定的发电机序号与数组下标进行一一对应的反向索引! 这样可以在寻找到对应的发电机数据后, 写入对应的结果数组!



#### 2. 分析

##### 1): *.OUT文件

```
SWING CASE: 39测试     POWERFLOW CASE: 039bpa             * * *  输 出 信 息  * * *                            Date: 2019-09-06

 * 发电机"BUS-30   100.0 "输出数据列表
 
     功角        (度)              最大值 =   -51.3867/   74.0          最小值 =   -51.3869/  186.0          参考发电机    BUS-31   100.0  
     0.0  -51.3868       0.0  -51.3868       1.0  -51.3868       2.0  -51.3868       3.0  -51.3868       4.0  -51.3867       5.0  -51.3867       6.0  -51.3867
     7.0  -51.3867       8.0  -51.3867       9.0  -51.3867      10.0  -51.3867      11.0  -51.3868      12.0  -51.3868      13.0  -51.3868      14.0  -51.3868
    15.0  -51.3868      16.0  -51.3868      17.0  -51.3868      18.0  -51.3868      19.0  -51.3868      20.0  -51.3868      21.0  -51.3868      22.0  -51.3868
    23.0  -51.3868      24.0  -51.3868      25.0  -51.3868      26.0  -51.3868      27.0  -51.3868      28.0  -51.3868      29.0  -51.3868      30.0  -51.3868
    31.0  -51.3868      32.0  -51.3868      33.0  -51.3868      34.0  -51.3868      35.0  -51.3868      36.0  -51.3868      37.0  -51.3868      38.0  -51.3868
    39.0  -51.3868      40.0  -51.3868      41.0  -51.3868      42.0  -51.3868      43.0  -51.3868      44.0  -51.3868      45.0  -51.3868      46.0  -51.3868
    47.0  -51.3868      48.0  -51.3868      49.0  -51.3868      50.0  -51.3868      51.0  -51.3868      52.0  -51.3868      53.0  -51.3868      54.0  -51.3868
    55.0  -51.3868      56.0  -51.3868      57.0  -51.3868      58.0  -51.3868      59.0  -51.3868      60.0  -51.3868      61.0  -51.3868      62.0  -51.3868
    
       速度偏差      (Hz)              最大值 =    14.8872/  295.0          最小值 =     0.0000/    0.0
     0.0    0.0000       0.0    0.0000       1.0    0.1273       2.0    0.2546       3.0    0.3820       4.0    0.5094       5.0    0.6368       6.0    0.7643
     7.0    0.8919       8.0    1.0196       9.0    1.1474      10.0    1.2755      10.0    1.2755      11.0    1.2734      12.0    1.2599      13.0    1.2395
    14.0    1.2154      15.0    1.1896      16.0    1.1639      17.0    1.1392      18.0    1.1166      19.0    1.0967      20.0    1.0802      21.0    1.0675
    22.0    1.0590      23.0    1.0548      24.0    1.0553      25.0    1.0606      26.0    1.0708      27.0    1.0860      28.0    1.1062      29.0    1.1314
    30.0    1.1617      31.0    1.1971      32.0    1.2377      33.0    1.2838      34.0    1.3355      35.0    1.3932      36.0    1.4575      37.0    1.5291
    38.0    1.6088      39.0    1.6979      40.0    1.7977      41.0    1.9098      42.0    2.0361      43.0    2.1784      44.0    2.3388      45.0    2.5186
    46.0    2.7182      47.0    2.9362      48.0    3.1684      49.0    3.4068      50.0    3.6398      51.0    3.8528      52.0    4.0308      53.0    4.1620
    ......................
```

*.OUT类型文件如上所示, 要求找出功角数据下面的与配置文件中给定的初始故障数据相同的数据, 如: 1: -51.3868.

**分析:** 由于有多台发电机都有这样的数据, 且有可能出现功角, 转速等多个条目, 但是功角一定是首个出现的条目. 所以可以先通过正则表达式寻找到: *发电机"BUS-30   100.0 "输出数据列表* 字段, 然后再按行找到对应的时间, 加入结果集即可.(这里用到了正则分隔.)

代码:

```python
############# 1. 故障时各台电机功角 #################
fault_power_angle = list()

# 读取发电机功角行向量
with open(data_folder + "\\" + out_file, 'r', encoding='gbk') as f:
    find_flag = False
    for line in f:
        line = line.strip()
        if line.find('发电机') >= 0 and line.find('输出数据列表') >= 0:
            motor_index = int(re.findall(r"\d+\.?\d*", line)[0])
            if (motor_number.__contains__(motor_index)):
                find_flag = True
                continue
        
        if find_flag:
            line_data = [x.strip() for x in re.split(r" +", line)]
            if len(line_data) < 8 or not is_all_float(line_data): 
                continue
            line_data = [float(x) for x in line_data]
            # 寻找故障停止时间的功角
            for i in range(0, len(line_data), 2):
                time = line_data[i]
                power_angle = line_data[i + 1]

                if time == fault_time:
                    fault_power_angle.append(power_angle)
                    find_flag = False
                    break

# print(fault_power_angle)
```

1.  按行读入文件(注: 在win下生成的文件为`gbk`编码, 所以需要添加encoding), 并判断是否包含相应的字符串<font color="#FF0000">使用`str.find()`方法</font>;

2.  一旦发现了数据标题标志, 将标题中的电机序号提出:

    ``` python
    # 原字符串为: *发电机"BUS-30   100.0 "输出数据列表*
    motor_index = int(re.findall(r"\d+\.?\d*", line)[0])
    ```

    使用**[\d+\.?\d*]**可以提取类似于: [数字.数字****]的效果(其中小数点: .可要可不要!)

3.  如果提取出的电机序号在给定的电机需求之内</red>`list.\__contains__(e)`</font>, 则将`find_flag`置为`True`, 此时表示, 要在接下来的数据中寻找所需的数据!

4.  当`find_flag`被置为`True`后, 表示接下来的数据可以在下文中找到!

5.  分析每一行的数据, 将数据按照<font color="#FF0000">多个空格为间隔拆分为多个数据.</font> 

6.  如果处理过的数据长度小于8(正常的数据应当每行为8个), 或者不全为float类型, 则这一行数据不合法! 判断<font color="#FF0000">数据是否为浮点数的函数:</font>

    ```python
    # 字符串小数判断
    def is_float(str):
        if str.count('.') == 1: #小数有且仅有一个小数点
            left = str.split('.')[0]  #小数点左边（整数位，可为正或负）
            right = str.split('.')[1]  #小数点右边（小数位，一定为正）
            lright = '' #取整数位的绝对值（排除掉负号）
            if str.count('-') == 1 and str[0] == '-': #如果整数位为负，则第一个元素一定是负号
                lright = left.split('-')[1]
            elif str.count('-') == 0:
                lright = left
            else:
                return False
            if right.isdigit() and lright.isdigit(): #判断整数位的绝对值和小数位是否全部为数字
                return True
            else:
                return False
        else:
            return False
    
    # 判断一整行的数据是否都为浮点数
    def is_all_float(arr):
        for s in arr:
            if not is_float(s):
                return False
        return True
    
    ```

7.  如果这一簇数据符合条件, 则将数据全部浮点数化:

    ```python
    line_data = [float(x) for x in line_data]
    ```

8.  之后寻找故障停止时间的功角数据, 由于数据为两个一组, 所以构建(0, len, 2)步长为2的index索引, 并寻找

9.  一旦找到, 就将数据结果加入结果集中, 并将find_flag标志位清空.



##### 2): *.lis文件

```
# File name: 33bpa.lis

Wall clock : Sun Sep 08 09:52:36 2019

<MULTI_NODE_EQUAL_RESULT>
.#      ???             ??????            ??????           ??????             ??????
.#                     G0+jB0(p.u.)        G1+jB1(p.u.)        G2+jB2(p.u.)       Im(kA)  Ia(deg)
.#----------------  ------------------  ------------------  ------------------  ------------------
B "BUS-30  " 100.0    0.0000    0.0000    3.4355  -51.9441    3.2023  -52.7944   30.0554  -86.2160
B "BUS-31  " 100.0    0.0000    0.0000    3.9110  -30.8303    3.5087  -33.5190   17.9425  -82.7702
B "BUS-32  " 100.0    0.0000    0.0000    3.6146  -36.5561    3.2913  -38.7305   21.2086  -84.3531
........................
```

`*.lis`文件格式如上所示, 要求提取指定行的`R`与`jX`的数据. 并构建对称矩阵.

```py
############# 2. 正序阻抗 R与X  #################
row = len(motor_number)
col = len(motor_number)

r_resistance_matrix = [[0] * row for c in range(col)]
x_resistance_matrix = [[0] * row for c in range(col)]

with open(data_folder + "\\" + lis_file, 'r', encoding='gbk') as f:
    for line in f:
        line = line.strip().replace("\"", "")
        line_data = [x.strip() for x in re.split(r" +", line)]
        if line_data[0] != "L":
            continue
        
        data_from = motor_dict[int(re.sub(r"\D", "", line_data[1]))]
        data_to = motor_dict[int(re.sub(r"\D", "", line_data[3]))]
        r = float(line_data[-4])
        x = float(line_data[-3])
        
        r_resistance_matrix[data_from][data_to] = r
        x_resistance_matrix[data_from][data_to] = x

    for i in range(row):
        for j in range(col):
            r_resistance_matrix[j][i] = r_resistance_matrix[i][j]
            x_resistance_matrix[j][i] = x_resistance_matrix[i][j]

# print(r_resistance_matrix)
# print(x_resistance_matrix)
```

代码如上所示.

1.  <font color="#FF0000">首先构建输出的矩阵NxN矩阵</font>

    ```python
    r_resistance_matrix = [[0] * row for c in range(col)]
    x_resistance_matrix = [[0] * row for c in range(col)]
    ```

2.  按行读入文件, 并进行数据预处理: <font color="#FF0000">删去前后空格, 替换多余符号, 拆分数据等</font>

3.  判断分隔的行首个所需字符为: `"L"`

4.  当满足条件时, 可以通过正则表达式提取数字:<font color="#FF0000">通过将非数字字符替换为空字符!</font>

    ```python
    data_from = motor_dict[int(re.sub(r"\D", "", line_data[1]))]
    data_to = motor_dict[int(re.sub(r"\D", "", line_data[3]))]
    ```

    其中: `\D` 表示非数字字符

5.  最终提取所需数据, 并通过反向索引字典, 找到对应的结果index位置, 加入!

6.  最后, 根据上三角矩阵, `生成对角矩阵`

    ```python
    for i in range(row):
        for j in range(col):
            r_resistance_matrix[j][i] = r_resistance_matrix[i][j]
            x_resistance_matrix[j][i] = x_resistance_matrix[i][j]
    ```

##### 3): *.swi文件

有了以上处理方法, 处理最后一个文件显得很是简单!

```python
############# 3. 发电机动能/平衡交流节点电压  #################
node_voltage = list()
motivate_energy = list()


with open(data_folder + "\\" + swi_file, 'r', encoding='gbk') as f:
    for line in f:
        line = line.strip().replace("\"", "")
        line_data = [x.strip() for x in re.split(r" +", line)]
        if line_data[0] != "MF":
            continue
        
        node_voltage.append(float(line_data[2]))
        motivate_energy.append(float(line_data[3]))

# print(node_voltage)
# print(motivate_energy)
```



##### 4): 保存文件

将文件按照配置路径保存为`*.txt`格式即可!

```python
def format_matrix(s):
    return s.replace("], [", ";")

############# 4. 保存 #################
with open(save_to, 'w') as f:
    f.write("############# 1. 故障时各台电机功角 #################\n")
    f.write(str(fault_power_angle) + "\n\n")
    f.write("############# 2. 正序阻抗 R与X  #################\n")
    f.write("# 1. 电阻\n")
    f.write(format_matrix(str(r_resistance_matrix))[1:-1] + "\n\n")
    f.write("# 2. 电抗\n")
    f.write(format_matrix(str(x_resistance_matrix))[1:-1] + "\n\n")
    f.write("############# 3. 发电机动能/平衡交流节点电压  #################\n")
    f.write("# 1. 节点电压\n")
    f.write(str(node_voltage) + "\n\n")
    f.write("# 2. 动能\n")
    f.write(str(motivate_energy) + "\n")

print("生成成功!")
```

此处由于保存时, *需要保存为MATLAB中的矩阵输入格式*, 所以, 可以通过将Python中的数组字符串之间的`], [`替换为`;`并删除前后多余的`[`和`]`即可!

### 三. 正则表达式总结







